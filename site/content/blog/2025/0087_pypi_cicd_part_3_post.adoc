= CI/CD Python – Partie 3 : Aller plus loin avec Poetry, Docker et la publication avancée
:jbake-type: post
:jbake-status: published
:jbake-title: CI/CD Python – Partie 3 : Aller plus loin avec Poetry, Docker et la publication avancée
:jbake-slug: cicd-python-partie-3
:jbake-date: 2025-07-19
:jbake-author: cheroliv
:date: 2025-07-19
:jbake-date: 2025-07-19
:toc: left
:toclevels: 3
:source-highlighter: pygments
:icons: font
:imagesdir: images
:description: Industrialiser votre pipeline CI/CD Python avec Poetry, Docker, publication conditionnelle et l’intégration d’outils avancés avec Renovate ou Dependabot.
:summary: Partie 3 - Guide complet pour mettre en place un pipeline CI/CD robuste avec GitHub Actions, du linting et tests automatisés jusqu'au déploiement automatique sur PyPI lors des releases.


Dans les deux premières parties de cette série, nous avons :
- Établi un pipeline CI/CD fonctionnel pour une application Python avec GitHub Actions et PyPI.
- Industrialisé ce pipeline avec des tests multi-versions, une publication progressive via Test PyPI, et des outils de qualité et de sécurité.

Dans cette troisième partie, nous allons aller **au-delà de la simple publication sur PyPI** pour construire une chaîne de CI/CD complète, robuste et professionnelle avec :
- **Poetry** pour un packaging moderne et une gestion optimisée des dépendances.
- **Docker** pour créer des builds reproductibles et multi-plateformes.
- **Publication conditionnelle** pour gérer des scénarios comme les release candidates.
- **Outils d’automatisation** (Renovate, Dependabot) pour maintenir le pipeline à jour sans effort.

== Intégration avec Poetry

Poetry remplace les anciens outils de packaging (setup.py, requirements.txt) en centralisant la gestion des dépendances et du build dans `pyproject.toml`.

=== Installation de Poetry
[source,shell]
----
# Installer Poetry
curl -sSL https://install.python-poetry.org | python3 -
# Vérifier la version
poetry --version
----

=== Initialisation du projet
[source,shell]
----
# Initialiser un nouveau projet avec Poetry
poetry init
# Suivre l'assistant pour renseigner : nom, version, description, licence, dépendances.
----

Cela génère un fichier `pyproject.toml` :
[source,toml]
----
[tool.poetry]
name = "playlist-downloader"
version = "0.1.0"
description = "CLI tool for managing YouTube playlists"
authors = ["Christophe Hérolivier <cheroliv@example.com>"]

[tool.poetry.dependencies]
python = ">=3.8"
typer = "^0.9.0"
yt-dlp = "^2023.7.6"
google-api-python-client = "^2.0.0"
google-auth-oauthlib = "^1.0.0"

[tool.poetry.group.dev.dependencies]
pytest = "^7.0"
mypy = "^1.0"
bandit = "^1.7"
safety = "^2.3"
black = "^23.0"
ruff = "^0.1"
----

=== Ajout et installation de dépendances
[source,shell]
----
poetry add typer yt-dlp google-api-python-client google-auth-oauthlib
poetry add --group dev pytest mypy black bandit safety ruff
----

=== Publication avec Poetry
Poetry gère nativement la publication :
[source,shell]
----
# Publication sur Test PyPI
poetry publish --build --repository test-pypi

# Publication sur PyPI
poetry publish --build
----

Cette commande utilise automatiquement les informations présentes dans `pyproject.toml`.

== Builds reproductibles avec Docker

Pour assurer des exécutions identiques en développement, CI/CD et production, Docker s’intègre parfaitement avec Poetry.

=== Exemple de Dockerfile
[source,dockerfile]
----
FROM python:3.11-slim

WORKDIR /app
COPY pyproject.toml poetry.lock ./
RUN pip install poetry
RUN poetry install --no-root --only main

COPY . .

CMD ["poetry", "run", "python", "cli.py"]
----

Cela garantit :
- Un environnement Python figé.
- Des dépendances verrouillées via `poetry.lock`.
- Une image exécutable sur tout système supportant Docker.

=== Intégration dans GitHub Actions
[source,yaml]
----
name: Docker Build

on:
  push:
    branches: [main]

jobs:
  build-docker:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Build Docker image
        run: docker build -t ghcr.io/${{ github.repository }}:latest .
      - name: Push Docker image
        run: docker push ghcr.io/${{ github.repository }}:latest
----

== Publication conditionnelle

Dans un pipeline professionnel, il faut pouvoir publier uniquement dans certains cas :
- Release candidates vers Test PyPI.
- Versions stables vers PyPI.
- Builds Docker déclenchés uniquement pour `main`.

[source,yaml]
----
- name: Publish to Test PyPI
  if: contains(github.ref, '-rc')
  run: poetry publish --build --repository test-pypi

- name: Publish to PyPI
  if: startsWith(github.ref, 'refs/tags/v')
  run: poetry publish --build
----

Cette approche évite les publications accidentelles.

== Automatisation des dépendances avec Renovate et Dependabot

Pour éviter que vos dépendances deviennent obsolètes, intégrez des outils de mise à jour automatique.

=== Dependabot
[source,yaml]
----
version: 2
updates:
  - package-ecosystem: "pip"
    directory: "/"
    schedule:
      interval: "weekly"
  - package-ecosystem: "github-actions"
    directory: "/"
    schedule:
      interval: "weekly"
----

Dependabot ouvre des PR chaque semaine pour mettre à jour les dépendances Python et GitHub Actions.

=== Renovate
[source,json]
----
{
  "extends": ["config:base"],
  "packageRules": [
    {
      "matchManagers": ["pip"],
      "groupName": "python-dependencies",
      "schedule": ["before 6am on monday"]
    }
  ]
}
----

Renovate permet un contrôle plus fin : regroupement de dépendances, planification, et règles avancées.

== Diagrammes PlantUML

=== Cas d’Usage – CI/CD avancé
[plantuml, usecase-cicd, svg]
----
@startuml
actor Developer
actor GitHub as "GitHub Actions"
actor PyPI
actor DockerRegistry as "Docker Registry"
actor Automation as "Renovate/Dependabot"

Developer --> (Push code)
(Trigger CI) --> GitHub
GitHub --> (Run Tests & Lint)
GitHub --> (Build Docker Image)
GitHub --> DockerRegistry
GitHub --> (Publish to Test PyPI)
GitHub --> (Promote to PyPI)
Automation --> (Update Dependencies)
@enduml
----

=== Séquence – Publication conditionnelle
[plantuml, sequence-cicd, svg]
----
@startuml
!theme vibrant
left to right direction
Developer -> GitHub: Push tag v1.2.3-rc
GitHub -> CI: Run tests
CI -> CD: Check release type
CD -> Test PyPI: Publish RC
Developer -> GitHub: Push tag v1.2.3
GitHub -> CD: Publish to PyPI
CD -> Docker Registry: Push Docker image
@enduml
----

=== États – Pipeline CI/CD
[plantuml, states-cicd, svg]
----
@startuml
[*] --> Idle
Idle --> CI_Running : push
CI_Running --> CI_Success : tests ok
CI_Running --> CI_Failed : tests fail
CI_Success --> CD_Running : tag detected
CD_Running --> CD_Success : publish ok
CD_Running --> CD_Failed : error
CD_Success --> [*]
@enduml
----

=== Déploiement – Architecture CI/CD

[plantuml, deployment-cicd, svg]
----
@startuml
node "Developer Machine" {
  component "Git Client"
}

node "GitHub Actions" {
  component "CI Workflow"
  component "CD Workflow"
}

node "Package Repositories" {
  artifact "Test PyPI"
  artifact "PyPI"
  artifact "Docker Registry"
}

"Developer Machine" --> "GitHub Actions"
"GitHub Actions" --> "Test PyPI"
"GitHub Actions" --> "PyPI"
"GitHub Actions" --> "Docker Registry"
@enduml
----

== Conclusion

Dans cette troisième partie, nous avons vu comment :
- Moderniser le packaging Python avec Poetry.
- Garantir des builds reproductibles via Docker.
- Mettre en place une publication conditionnelle.
- Automatiser la mise à jour des dépendances.

Vous disposez désormais d’un pipeline CI/CD **complet, industrialisé et sécurisé**, prêt à évoluer avec vos projets.


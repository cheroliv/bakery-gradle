= La Navigation Contextuelle : Comment Rendre un Menu Vraiment Intelligent avec Thymeleaf
Cheroliv <cheroliv@cheroliv.com>
:jbake-status: draft
:jbake-type: post
:jbake-tags: blog, frontend, thymeleaf, webdev, ux, tutoriel, java, jbake
:jbake-date: 2025-09-02 17:00:00
:toc: left
:summary: Un guide détaillé sur l'implémentation de liens de navigation contextuels dans un template Thymeleaf pour créer une expérience utilisateur plus fluide et intuitive, en évitant les redirections déroutantes.

En matière de conception de sites web, nous nous concentrons souvent sur les grands éléments : le design, la performance, le contenu. Pourtant, ce sont parfois les détails les plus subtils qui distinguent une expérience utilisateur (UX) simplement fonctionnelle d'une expérience véritablement intuitive et agréable.

L'un de ces détails, souvent négligé, est le comportement des liens dans le menu de navigation. Un menu "intelligent" ne devrait-il pas savoir sur quelle page se trouve l'utilisateur et adapter ses liens en conséquence ?

Dans cet article, nous allons explorer comment j'ai implémenté une logique de navigation contextuelle sur mon site, en utilisant la puissance du moteur de templates Thymeleaf pour résoudre un problème d'UX courant et créer une navigation sans friction.

== Le Problème : Un Lien, Deux Comportements Attendus

Mon site, comme beaucoup d'autres, possède une page d'accueil (`index.html`) qui regroupe plusieurs sections (À propos, Services, Blog, etc.) et des pages dédiées, comme une page principale pour le blog (`blog.html`).

Le problème se cristallise autour du lien "Blog" dans le menu de navigation :

1.  **Depuis la page d'accueil :** L'utilisateur s'attend à ce que le clic sur "Blog" le fasse défiler en douceur vers la section blog de la même page. Le lien doit donc être une ancre : `href="#blog"`.
2.  **Depuis n'importe quelle autre page (par exemple, la page `blog.html` elle-même) :** L'utilisateur s'attend à ce que le clic sur "Blog" le mène (ou le maintienne) sur la page principale du blog. Le lien doit donc être une URL absolue : `href="blog.html"`.

Le comportement par défaut, avec un lien statique, est forcément erroné dans l'un des deux cas. Si le lien est toujours `index.html#blog`, un utilisateur déjà sur la page du blog sera redirigé vers la page d'accueil, ce qui est une expérience frustrante et déroutante.

Voici une visualisation du flux utilisateur problématique :

[plantuml, target=contextual-nav-problem, format=svg]
----
@startuml
skinparam componentStyle uml2

actor Utilisateur

package "Site Web" {
  component [Page d\'accueil] as Index
  component [Page Blog] as BlogPage
}

Utilisateur --> Index : Visite
Index --> Index : Clic sur "Blog" (href="index.html#blog")\n**OK : Scroll vers la section**

Utilisateur --> BlogPage : Visite
BlogPage --> Index : Clic sur "Blog" (href="index.html#blog")\n**NON OK : Redirection inattendue !**

note right of BlogPage
  L\'utilisateur est arraché
  à sa page actuelle pour
  revenir à l\'accueil.
end note
@enduml
----

== La Solution : Laisser le Serveur Décider avec Thymeleaf

Plutôt que de tenter de résoudre ce problème côté client avec JavaScript, ce qui peut entraîner des délais et des clignotements, la solution la plus élégante est de le gérer côté serveur, au moment de la génération de la page. C'est là que Thymeleaf brille.

L'idée est simple : le template du menu doit savoir si la page en cours de rendu est la page d'accueil ou non. En fonction de cette information, il générera le bon `href` pour chaque lien.

=== Étape 1 : Créer une Variable de Contexte

Dans le template du menu (`menu.thyme`), nous pouvons utiliser l'attribut `th:with` pour déclarer une variable locale. Nous l'appellerons `isIndexPage`. Cette variable sera un booléen (`true` ou `false`).

Pour déterminer sa valeur, nous inspectons l'objet `content` fourni par JBake (le générateur de site statique que j'utilise). L'attribut `content.uri` nous donne le chemin du fichier en cours de traitement.

[source,html]
----
<!-- Placé sur un élément parent, ici le fragment 'menu' -->
<div th:fragment="menu" th:with="isIndexPage=${content.uri == null or content.uri == '' or content.uri == 'index.html'}">
    <!-- ... le reste de la nav ... -->
</div>
----

Cette expression `th:with` signifie : "Crée une variable `isIndexPage` et mets-la à `true` si l'URI du contenu est nul, vide, ou est `index.html`. Sinon, mets-la à `false`."

=== Étape 2 : Utiliser des Expressions Conditionnelles (Ternaires)

Maintenant que nous avons notre variable `isIndexPage`, nous pouvons l'utiliser directement dans les attributs `th:href` des liens de navigation grâce à une expression ternaire.

La syntaxe d'une ternaire en Thymeleaf est : `(condition) ? (valeur si vrai) : (valeur si faux)`.

Voici comment nous l'appliquons au lien "Blog" :

[source,html]
----
<li class="nav-item">
    <a class="nav-link" th:href="${isIndexPage ? '#blog' : content.rootpath + 'blog.html'}">Blog</a>
</li>
----

Décortiquons cette ligne :
-   `th:href="..."` : Indique à Thymeleaf de traiter cet attribut.
-   `${isIndexPage ? ...}` : Évalue notre variable.
-   `? '#blog'` : Si `isIndexPage` est `true`, la valeur de `href` sera `#blog`.
-   `: content.rootpath + 'blog.html'` : Si `isIndexPage` est `false`, la valeur sera le chemin racine (`content.rootpath`) suivi de `blog.html`, créant ainsi un lien absolu correct.

=== Étape 3 : Généraliser le Modèle

Cette logique est si puissante qu'elle peut être appliquée à tous les liens du menu qui pointent vers une section de la page d'accueil.

[source,html]
----
<ul class="navbar-nav ms-auto">
    <li class="nav-item">
        <a class="nav-link" th:href="${isIndexPage ? '#home' : content.rootpath + 'index.html#home'}">Accueil</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" th:href="${isIndexPage ? '#about' : content.rootpath + 'index.html#about'}">À propos</a>
    </li>
    <li class="nav-item">
        <a class="nav-link" th:href="${isIndexPage ? '#services' : content.rootpath + 'index.html#services'}">Services</a>
    </li>
    <!-- ... etc pour les autres liens ... -->
    <li class="nav-item">
        <a class="nav-link" th:href="${isIndexPage ? '#blog' : content.rootpath + 'blog.html'}">Blog</a>
    </li>
</ul>
----

Le flux logique de génération des liens devient alors le suivant :

[plantuml, target=contextual-nav-solution, format=svg]
----
@startuml
title Flux de Décision pour la Génération d\'un Lien

start
:Requête pour une page (ex: blog.html);

if (URI de la page == "index.html" ?) then (oui)
  :La variable `isIndexPage` est `true`;
  :Générer le lien "Blog" avec `href="#blog"`;
else (non)
  :La variable `isIndexPage` est `false`;
  :Générer le lien "Blog" avec `href="blog.html"`;
endif

:Le lien est inséré dans le HTML;
stop
@enduml
----

== Conclusion : La Marque d'une Finition Soignée

Cette approche, bien que simple à mettre en œuvre, a un impact profond sur la qualité perçue du site. La navigation devient prévisible, logique et sans friction. L'utilisateur n'est jamais surpris ou frustré par un comportement inattendu.

C'est un excellent exemple de la façon dont les moteurs de templates côté serveur, comme Thymeleaf, nous permettent de construire des expériences plus riches et plus intelligentes avant même que le premier octet de HTML ne soit envoyé au navigateur. En prenant un moment pour réfléchir au contexte de l'utilisateur, nous pouvons transformer un simple menu en un véritable guide intelligent pour notre site.

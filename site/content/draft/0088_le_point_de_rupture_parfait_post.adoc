= Le Point de Rupture Parfait : La Quête d'un Menu Responsive Dynamique
cheroliv
2025-09-05
:jbake-status: published
:jbake-tags: bootstrap, javascript, css, frontend, responsive-design, webdev
:jbake-slug: le-point-de-rupture-parfait-menu-responsive
:jbake-summary: Récit du débogage d'un menu Bootstrap pour obtenir un point de rupture dynamique parfait, explorant les fausses pistes CSS et JavaScript avant d'arriver à une solution simple et robuste.
:toc: left
:source-highlighter: prettify
:icons: font

Sur le papier, rendre un menu de navigation responsive semble être un problème résolu depuis longtemps. Bootstrap, avec son système de `navbar-expand-*`, nous offre une solution clé en main. Mais que se passe-t-il lorsque les points de rupture fixes ne suffisent pas ? Que faire quand le contenu de notre menu est dynamique et que l'on veut un passage en mode "burger" *exactement* au moment où la mise en page risque de se casser, sans aucun clignotement ou vilain passage à la ligne ?

C'est le défi que j'ai rencontré en finalisant l'intégration de mon nouveau thème Bootstrap 5. L'objectif, défini dans l'User Story US-40, était clair :

____
*En tant que visiteur, je veux que le menu de navigation passe en mode "burger" **immédiatement** dès qu'un de ses éléments n'a plus assez de place, afin de garantir que le menu reste toujours sur une seule ligne, lisible et esthétique, quelle que soit la résolution de l'écran.*
____

Ce qui semblait être un simple ajustement s'est transformé en une véritable odyssée à travers les fausses pistes et les impasses techniques.

== L'Écueil n°1 : La Fausse Bonne Idée du `text-nowrap`

Le problème initial était simple : juste avant le point de rupture `lg` de Bootstrap, le texte d'un lien comme "À propos" ou le sélecteur de thème passait sur deux lignes. C'était inesthétique.

Mon premier réflexe, presque pavlovien, fut d'appliquer la classe utilitaire de Bootstrap `.text-nowrap` au conteneur `<ul>` des liens de navigation.

[source,html]
----
<!-- Tentative 1 : La fausse piste -->
<ul class="navbar-nav ms-auto align-items-center text-nowrap">
    ...
</ul>
----

Le résultat ? Le texte ne passait effectivement plus à la ligne. Victoire ? Pas vraiment. Un nouveau problème, bien pire, est apparu : les éléments du menu, ne pouvant plus passer à la ligne, débordaient de leur conteneur et poussaient le sélecteur de thème hors de l'écran. Le menu était cassé, mais le mode burger n'était toujours pas déclenché.

== L'Écueil n°2 : La Spirale de la Sur-Ingénierie JavaScript

Abandonnant la solution CSS pure, je me suis tourné vers JavaScript, convaincu qu'il fallait une logique plus "intelligente". L'idée semblait robuste : mesurer la largeur de tous les éléments du menu et la comparer à la largeur disponible. Simple, non ? C'est ici que nous sommes tombés dans le piège de la sur-ingénierie, en essayant de remplacer les mécanismes naturels du navigateur par notre propre logique.

=== Tentative A : Le Calcul des Largeurs et l'Effet de Scintillement

La première version du script calculait la somme des `offsetWidth` de chaque élément du menu. Si cette somme dépassait la largeur du conteneur, une classe `.force-burger-mode` était ajoutée.

Le résultat fut un scintillement incessant du menu au point de rupture. Pourquoi ? Parce que nous avions créé une boucle de rétroaction parfaite :

1.  **Le script mesure :** Il constate que les éléments débordent.
2.  **Le script agit :** Il ajoute la classe qui, via le CSS, fait `display: none !important` sur le conteneur des liens.
3.  **Le navigateur redessine :** Le menu disparaît.
4.  **Le script re-mesure :** L' `offsetWidth` du menu caché est maintenant `0`. Le script conclut donc qu'il y a largement assez de place.
5.  **Le script annule :** Il retire la classe `.force-burger-mode`.
6.  **Le navigateur redessine :** Le menu réapparaît, et le cycle recommence.

Voici une illustration de ce cycle infernal :

[plantuml]
----
@startuml
participant "Navigateur" as Browser
participant "Script JS" as Script

loop Au point de rupture critique
    Browser -> Script: Déclenche onResize()
    activate Script
    Script -> Browser: Mesure les largeurs (offsetWidth > 0)
    note right: L'espace manque !
    Script -> Browser: Ajoute la classe `.force-burger-mode`
    Browser -> Script: Le menu est masqué (offsetWidth = 0)
    deactivate Script

    Browser -> Script: Déclenche onResize()
    activate Script
    Script -> Browser: Mesure les largeurs (offsetWidth = 0)
    note right: L'espace est suffisant !
    Script -> Browser: Retire la classe `.force-burger-mode`
    Browser -> Script: Le menu réapparaît (offsetWidth > 0)
    deactivate Script
end
@enduml
----

=== Tentative B : La Mémorisation des Largeurs

Pour contrer le scintillement, l'idée suivante fut de "mémoriser" les largeurs des éléments une seule fois au chargement de la page. Le script ne mesurerait plus les éléments en direct, mais se baserait sur ces valeurs stockées.

Bien que techniquement fonctionnelle, cette approche était un pansement sur une jambe de bois. Elle ajoutait de la complexité pour corriger un problème que nous avions nous-mêmes créé. C'était le signe ultime que nous faisions fausse route : au lieu de travailler *avec* le flux du document et les règles de Bootstrap, nous luttions *contre* elles avec une logique de plus en plus alambiquée.

== La Solution : Revenir à la Simplicité et à la Source du Problème

Après ces impasses, la solution est apparue en revenant à la définition même du problème, telle que décrite dans la résolution de l'US-40. Le bug n'est pas le manque de place, mais bien **le passage à la ligne du texte**. C'est donc ce symptôme qu'il faut détecter, car il est le signe le plus fiable et le plus direct que la mise en page est cassée.

La stratégie finale est d'une simplicité redoutable :

1.  **On laisse faire le navigateur :** On retire toute contrainte comme `text-nowrap`. On laisse le texte des liens passer à la ligne dès que l'espace manque.
2.  **On observe intelligemment :** Un script JavaScript observe les éléments du menu. Il prend la hauteur du premier élément comme référence.
3.  **On détecte instantanément :** À chaque redimensionnement, le script vérifie si l'un des autres éléments est devenu plus haut que la référence. Si c'est le cas, cela signifie qu'un retour à la ligne vient de se produire.
4.  **On agit :** Dès la détection, le script ajoute une classe `.force-burger-mode` à la barre de navigation, et le CSS s'occupe de transformer le menu en burger.

Cette détection est si rapide que l'utilisateur ne voit jamais le menu sur deux lignes.

=== L'Implémentation Finale

Voici les briques de la solution qui fonctionne parfaitement.

.Le JavaScript (`site/assets/js/script.js`)
[source,javascript]
----
class DynamicNavbarBreakpoint {
    constructor(navbar) {
        this.navbar = navbar;
        this.navbarNav = navbar.querySelector('.navbar-nav');
        this.navItems = this.navbarNav ? Array.from(this.navbarNav.children) : [];
        this.init();
    }

    init() {
        if (!this.navbarNav || this.navItems.length === 0) return;

        const resizeObserver = new ResizeObserver(() => this.checkWrap());
        resizeObserver.observe(this.navbar);
        document.fonts?.ready.then(() => this.checkWrap());
        this.checkWrap();
    }

    checkWrap() {
        const referenceHeight = this.navItems[0].offsetHeight;
        let isWrapped = false;

        for (let i = 1; i < this.navItems.length; i++) {
            // Une tolérance de 2px évite les faux positifs
            if (this.navItems[i].offsetHeight > referenceHeight + 2) {
                isWrapped = true;
                break;
            }
        }

        if (isWrapped) {
            this.navbar.classList.add('force-burger-mode');
        } else {
            this.navbar.classList.remove('force-burger-mode');
        }
    }
}
----

.Le CSS (`site/assets/css/styles.css`)
[source,css]
----
/* Par défaut, sur grand écran, le burger est caché et le menu visible */
.navbar-expand-lg .navbar-toggler {
    display: none;
}
.navbar-expand-lg .navbar-collapse {
    display: flex !important;
}

/* Quand notre classe est active, on inverse : burger visible, menu caché */
.force-burger-mode.navbar-expand-lg .navbar-toggler {
    display: block;
}
.force-burger-mode.navbar-expand-lg .navbar-collapse {
    display: none !important;
}

/* On s'assure que le menu s'affiche quand on clique sur le burger */
.force-burger-mode.navbar-expand-lg .navbar-collapse.show {
    display: block !important;
}
----

== Conclusion

Cette aventure de débogage est un excellent rappel : les solutions les plus complexes ne sont pas toujours les meilleures. En revenant à la source du problème -- un simple retour à la ligne -- et en utilisant un mécanisme de détection direct et léger, nous avons pu obtenir un comportement parfaitement fluide et robuste. Le menu s'adapte désormais dynamiquement à son contenu, offrant une expérience utilisateur sans faille, quelle que soit la résolution. Parfois, il suffit de laisser le "bug" se produire pour mieux le maîtriser.
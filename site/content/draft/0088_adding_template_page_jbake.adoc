= Ajouter une Nouvelle Page de Template à votre Projet JBake
cheroliv
:jbake-type: post
:jbake-status: published
:jbake-date: 2025-09-01
:jbake-tags: jbake, template, asciidoc, développement web
:jbake-summary: Découvrez comment ajouter facilement une nouvelle page de template à votre projet JBake, en utilisant Thymeleaf et AsciiDoc pour une gestion de contenu efficace.
:jbake-reading-time: 5 minutes
:jbake-slug: adding_thymeleaf_template_page_jbake
:jbake-author: cheroliv
:date: 2025-09-01
:toc: left
:toclevels: 3
:source-highlighter: pygments
:icons: font
:imagesdir: images
:summary: Découvrez comment ajouter facilement une nouvelle page de template à votre projet JBake, en utilisant Thymeleaf et AsciiDoc pour une gestion de contenu efficace.

Bienvenue dans ce guide rapide sur l'ajout d'une nouvelle page de template à votre projet JBake. Que vous souhaitiez créer une page "À propos", une section "Services" ou toute autre page statique, JBake, combiné à Thymeleaf et AsciiDoc, offre une approche flexible et puissante.

== Comprendre la Structure d'un Projet JBake

Avant de plonger dans les détails, il est essentiel de comprendre comment JBake organise votre contenu et vos templates.

.Structure Simplifiée d'un Projet JBake
[plantuml, jbake-structure, png]
----
@startuml
folder "Projet JBake" {
    folder "site" {
        folder "content" {
            file "ma-nouvelle-page.adoc"
            file "index.adoc"
            folder "blog" {
                file "mon-article.adoc"
            }
        }
        folder "templates" {
            file "ma-nouvelle-page.thyme"
            file "index.thyme"
            file "post.thyme"
            file "header.thyme"
            file "footer.thyme"
        }
        file "jbake.properties"
    }
    file "build.gradle.kts"
}
@enduml
----

*   `site/content/`: Contient vos fichiers de contenu (AsciiDoc, Markdown, HTML). JBake les traite pour générer les pages finales.
*   `site/templates/`: Contient les fichiers de template (Thymeleaf, FreeMarker, Handlebars). Ils définissent la structure et le design de vos pages.
*   `jbake.properties`: Le fichier de configuration principal de JBake.

== La Problématique : Pourquoi un Fichier de Contenu est Indispensable ?

Une erreur courante, et que nous avons nous-mêmes rencontrée, est de penser qu'il suffit de créer un fichier `.thyme` dans `site/templates/` pour que JBake génère la page HTML correspondante. Cependant, JBake fonctionne sur le principe de la *transformation de contenu*. Il a besoin d'un fichier source dans le dossier `site/content/` pour déclencher le processus de génération d'une page HTML.

Même si votre page est principalement construite via Thymeleaf et n'a pas beaucoup de contenu dynamique provenant d'AsciiDoc, vous devez *toujours* fournir un fichier de contenu minimal. Ce fichier sert de "déclencheur" pour JBake.

.Le Rôle du Fichier de Contenu Minimal
[plantuml, content-trigger, png]
----
@startuml
participant "Développeur" as Dev
participant "site/templates/ma-page.thyme" as Template
participant "site/content/ma-page.adoc" as ContentFile
participant "JBake Engine" as JBake
participant "site/output/ma-page.html" as Output

Dev -> Template : Crée le template (structure HTML)
Dev -> ContentFile : Crée le fichier de contenu (même minimal)
JBake -> ContentFile : Détecte le fichier de contenu
JBake -> Template : Associe le template au contenu (via jbake-type ou nom)
JBake -> Output : Génère la page HTML
Output --> Dev : Page HTML générée
@enduml
----

Sans un fichier `ma-page.adoc` (ou `.html`, `.md`) dans `site/content/`, JBake n'aura aucune instruction pour créer `ma-page.html` dans `site/output/`, même si `ma-page.thyme` existe. Le fichier de contenu, même vide ou avec juste des métadonnées, est le point d'entrée que JBake utilise pour savoir qu'une page doit être générée et quel template lui appliquer.

C'est une distinction importante à comprendre, surtout lorsque l'on vient de frameworks où les templates peuvent être directement mappés à des routes sans fichier de contenu explicite. Avec JBake, le contenu est roi pour initier la génération.

== Étape 1 : Créer le Fichier de Contenu (AsciiDoc)

Commençons par créer le fichier de contenu pour notre nouvelle page. Supposons que nous voulions une page "Services".

Créez un fichier `services.adoc` dans `site/content/` avec le contenu suivant :

[source,asciidoc]
----
= Nos Services
cheroliv
:jbake-type: page
:jbake-status: published
:jbake-date: 2025-09-01
:jbake-tags: services, entreprise
:jbake-summary: Découvrez la gamme complète de nos services professionnels.

Bienvenue sur notre page de services. Nous offrons une expertise dans plusieurs domaines clés pour vous aider à atteindre vos objectifs.

== Développement Web
Nous créons des applications web modernes et performantes...

== Conseil Technique
Nos experts vous accompagnent dans vos choix technologiques...
----

*   `:jbake-type: page`: Indique à JBake que c'est une page statique, et non un article de blog.
*   `:jbake-status: published`: La page sera générée.
*   `:jbake-date: ...`: Date de publication.
*   `:jbake-summary: ...`: Un court résumé pour les listes de pages ou les métadonnées SEO.

== Étape 2 : Créer le Fichier de Template (Thymeleaf)

Ensuite, nous avons besoin d'un template Thymeleaf qui définira comment le contenu de `services.adoc` sera rendu.

Créez un fichier `services.thyme` dans `site/templates/` :

[source,xml]
----
<!DOCTYPE html SYSTEM "http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-4.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org">
<head th:replace="header.thyme::head"/>
<body>
    <div th:replace="menu.thyme::menu"/>
    <main id="main-content" class="container mt-5">
        <div class="row">
            <div class="col-lg-10 offset-lg-1">
                <h1 class="display-4" th:text="${content.title}">Titre de la Page</h1>
                <p class="lead text-muted" th:text="${content.summary}">Résumé de la page.</p>
                <hr/>
                <div th:utext="${content.body}">
                    <!-- Le contenu AsciiDoc rendu sera inséré ici -->
                </div>
            </div>
        </div>
    </main>
    <div th:replace="footer.thyme::footer"></div>
</body>
</html>
----

Ce template est assez standard :
*   Il inclut `header.thyme`, `menu.thyme` et `footer.thyme` pour une cohérence visuelle.
*   `th:text="${content.title}"` et `th:text="${content.summary}"` affichent le titre et le résumé définis dans `services.adoc`.
*   `th:utext="${content.body}"` est crucial : il insère le contenu HTML généré par AsciiDoctor à partir de votre fichier `services.adoc`.

== Vos Outils de Génération et Déploiement

Pour générer et déployer votre site, vous utilisez des outils spécifiques à votre projet. Il est crucial de les comprendre pour une gestion efficace.

=== Le Script `jbake.sh`

Ce script shell est votre raccourci pour lancer la génération du site avec JBake en mode "build" et "serve" (si configuré pour servir localement).

[source,bash]
----
#!/usr/bin/env bash
jbake -b -s site build/jbake/;
----

*   `jbake -b`: Lance le processus de "bake" (génération) du site.
*   `-s site`: Spécifie le répertoire source de votre site (ici, le dossier `site`).
*   `build/jbake/`: Indique le répertoire de destination où le site généré sera placé.

=== Les Tâches Gradle `bake` et `publishSite`

Votre fichier `build.gradle.kts` contient des tâches Gradle pour une gestion plus intégrée de la génération et du déploiement.

[source,kotlin]
----
jbake {
    srcDirName = bakeSrcPath
    destDirName = bakeDestinationDirPath
    configuration["asciidoctor.option.requires"] = "asciidoctor-diagram"
    configuration["asciidoctor.attributes"] = mapOf(
        "sourceDir" to projectDir,
        "imagesDir" to "diagrams",
        "imagesoutdir" to "${tasks.bake.get().input}/assets/diagrams"
    )
}

tasks.register("publishSite") {
    group = "managed"
    description = "Publish site online."
    dependsOn(tasks.bake)
    doFirst { createCnameFile() }
    doLast {
        pushPages(
            destPath = { "${layout.buildDirectory.get().asFile.absolutePath}${getDefault().separator}$bakeDestinationDirPath" },
            pathTo = { "${layout.buildDirectory.get().asFile.absolutePath}${getDefault().separator}${localConf.pushPage.to}" }
        )
    }
}
----

*   **`jbake` (plugin configuration)**:
    *   `srcDirName` et `destDirName`: Définissent les chemins source et de destination pour JBake.
    *   `asciidoctor.option.requires` et `asciidoctor.attributes`: Configurées pour prendre en charge les diagrammes AsciiDoctor (PlantUML).
*   **`publishSite` (tâche Gradle)**:
    *   `group = "managed"`: Organise la tâche sous un groupe spécifique.
    *   `dependsOn(tasks.bake)`: S'assure que le site est généré avant d'être publié.
    *   `doFirst { createCnameFile() }`: Crée le fichier CNAME avant la publication.
    *   `doLast { pushPages(...) }`: Exécute la logique de déploiement vers GitHub Pages en utilisant les configurations définies dans `localConf`.

== Étape 3 : Générer et Vérifier

Maintenant, il est temps de générer votre site et de voir votre nouvelle page. Vous pouvez utiliser votre script `jbake.sh` ou la tâche Gradle `bake`.

[source,bash]
----
./jbake.sh
# Ou via Gradle :
./gradlew bake
----

Après la génération, vous devriez trouver un fichier `services.html` dans votre dossier `site/output/`. Ouvrez-le dans votre navigateur pour vérifier que tout s'affiche correctement.

Si vous souhaitez déployer votre site, utilisez la tâche Gradle `publishSite` :

[source,bash]
----
./gradlew publishSite
----

.Flux de Génération d'une Nouvelle Page
[plantuml, page-generation-flow, png]
----
@startuml
actor Developer as Dev
participant "site/content/services.adoc" as Adoc
participant "site/templates/services.thyme" as Thyme
participant "JBake Engine" as JBake
participant "site/output/services.html" as Html

Dev -> Adoc : Crée le contenu
Dev -> Thyme : Crée le template
Dev -> Dev : Lance la génération (./jbake.sh ou ./gradlew bake)
JBake -> Adoc : Lit le contenu
JBake -> Thyme : Applique le template
JBake -> Html : Génère la page HTML finale
Dev -> Html : Vérifie le résultat dans le navigateur
@enduml
----

== Conclusion

L'ajout d'une nouvelle page de template dans JBake est un processus simple et logique. En comprenant la séparation entre le contenu (AsciiDoc) et la présentation (Thymeleaf), vous pouvez étendre votre site statique avec une grande flexibilité. N'oubliez pas de toujours vérifier le rendu final dans votre navigateur après chaque modification.

Bon codage !

== Compléments d'Information sur la Configuration du Projet

Pour une compréhension complète de la configuration de ce projet, voici le contenu des fichiers `build.gradle.kts`, `gradle/libs.versions.toml` et `settings.gradle.kts`.

=== Fichier `build.gradle.kts`

[source,kotlin]
----
import RepositoryConfiguration.Companion.CNAME
import RepositoryConfiguration.Companion.ORIGIN
import RepositoryConfiguration.Companion.REMOTE
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.databind.SerializationFeature.WRITE_DATES_AS_TIMESTAMPS
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory
import com.fasterxml.jackson.module.kotlin.readValue
import com.fasterxml.jackson.module.kotlin.registerKotlinModule
import org.eclipse.jgit.api.Git
import org.eclipse.jgit.api.Git.init
import org.eclipse.jgit.revwalk.RevCommit
import org.eclipse.jgit.storage.file.FileRepositoryBuilder
import org.eclipse.jgit.transport.PushResult
import org.eclipse.jgit.transport.URIish
import org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider
import org.gradle.api.tasks.wrapper.Wrapper.DistributionType.BIN
import java.io.IOException
import java.nio.charset.StandardCharsets.UTF_8
import java.nio.file.FileSystems.getDefault

/*=================================================================================*/

buildscript {
    repositories {
        google()
        mavenCentral()
    }

    dependencies {
        listOf(
            libs.jbake,
            libs.slf4j.simple,
            libs.commons.io,
            libs.xz,
            libs.jackson.module.kotlin,
            libs.jackson.dataformat.yaml,
            libs.jackson.datatype.jsr310,
            libs.jackson.module.jsonSchema,
            libs.jackson.databind.yaml,
            libs.commons.lang3,
            libs.jgit.core,
            libs.jgit.archive,
            libs.jgit.ssh,
            libs.asciidoctorj.diagram,
            libs.asciidoctorj.diagram.plantuml,
            libs.kotlin.reflect,
            libs.kotlin.stdlib.jdk8,
            libs.kotlinx.coroutines.core,
            libs.kotlinx.serialization.json
        ).map { classpath(it) }
    }
}

plugins { this.id("org.jbake.site") }

/*=================================================================================*/

data class GitPushConfiguration(
    val from: String,
    val to: String,
    val repo: RepositoryConfiguration,
    val branch: String,
    val message: String,
)

data class RepositoryConfiguration(
    val name: String,
    val repository: String,
    val credentials: RepositoryCredentials,
) {
    companion object {
        const val ORIGIN = "origin"
        const val CNAME = "CNAME"
        const val REMOTE = "remote"
    }
}

data class RepositoryCredentials(val username: String, val password: String)

data class SiteConfiguration(
    val bake: BakeConfiguration,
    val pushPage: GitPushConfiguration,
    val pushMaquette: GitPushConfiguration,
    val pushSource: GitPushConfiguration? = null,
    val pushTemplate: GitPushConfiguration? = null,
)

data class BakeConfiguration(
    val srcPath: String,
    val destDirPath: String,
    val cname: String?,
)

/*=================================================================================*/

/*=================================================================================*/

sealed class FileOperationResult {
    sealed class GitOperationResult {
        data class Success(
            val commit: RevCommit, val pushResults: MutableIterable<PushResult>?
        ) : GitOperationResult()

        data class Failure(val error: String) : GitOperationResult()
    }

    object Success : FileOperationResult()
    data class Failure(val error: String) : FileOperationResult()
}

/*=================================================================================*/

val mapper: ObjectMapper
    get() = YAMLFactory()
        .let(::ObjectMapper)
        .disable(WRITE_DATES_AS_TIMESTAMPS)
        .registerKotlinModule()

/*=================================================================================*/

val localConf: SiteConfiguration
    get() = readSiteConfigurationFile {
        "$rootDir${getDefault().separator}${properties["managed_config_path"]}"
    }

fun readSiteConfigurationFile(
    configPath: () -> String
): SiteConfiguration = try {
    configPath().let(::File).let(mapper::readValue)
} catch (e: Exception) {
// Handle exception or log error
    SiteConfiguration(
        BakeConfiguration(srcPath = "", destDirPath = "", cname = null),
        pushPage = GitPushConfiguration(
            from = "", to = "", repo = RepositoryConfiguration(
                name = "",
                repository = "",
                credentials = RepositoryCredentials(username = "", password = "")
            ), branch = "", message = ""
        ),
        pushMaquette = GitPushConfiguration(
            from = "", to = "", repo = RepositoryConfiguration(
                name = "",
                repository = "",
                credentials = RepositoryCredentials("", "")
            ), branch = "", message = ""
        ),
    )
}

/*=================================================================================*/

val bakeSrcPath: String get() = localConf.bake.srcPath

val bakeDestinationDirPath: String get() = localConf.bake.destDirPath

/*=================================================================================*/

fun createCnameFile() {
    if (localConf.bake.cname != null && localConf.bake.cname!!.isNotBlank())
        file(
            "${project.layout.buildDirectory.get().asFile.absolutePath}${getDefault().separator}${localConf.bake.destDirPath}${getDefault().separator}${CNAME}"
        ).run {
            if (exists() && isDirectory) {
                logger.info("$name exists as directory.")
                deleteRecursively()
            } else logger.info("$name does not exist as directory.")
            if (exists()) {
                logger.info("$name successfully deleted.")
                delete()
            } else logger.info("$name does not exist as file.")
            if (exists()) throw "$name file should not exist.".run(::IOException)
            else logger.info("$name does not exist as file or directory.")
            if (!createNewFile()) throw "Cannot create $name file.".run(::IOException)
            else logger.info("$name successfully created.")
            if (!exists()) throw "$name file should exist.".run(::IOException)
            else logger.info("$name file exists.")
            appendText(localConf.bake.cname ?: "", UTF_8)
            if (!(exists() && !isDirectory)) throw "$name file should exist as file not as directory.".run(::IOException) else logger.info("$name file exists as file and not directory.")
        }
}


/*=================================================================================*/

fun createRepoDir(path: String): File = path
    .let(::File)
    .apply {
        if (exists() && !isDirectory)
            if (delete()) logger.info("$name exists as file and successfully deleted.")
            else throw "$name exists and must be a directory".run(::IOException)

        if (exists()) if (deleteRecursively()) logger.info("$name exists as directory and successfully deleted.")
        else throw "$name exists as a directory and cannot be deleted".run(::IOException)
        if (!exists()) logger.info("$name does not exist.")
        else throw IOException("$name must not exist anymore.")
        if (!exists()) {
            if (mkdir()) logger.info("$name as directory successfully created.")
            else throw IOException("$name as directory cannot be created.")
        }
    }

/*=================================================================================*/

fun copyBakedFilesToRepo(
    bakeDirPath: String, repoDir: File
): FileOperationResult = try {
    bakeDirPath
        .also { "bakeDirPath : $it".let(logger::info) }
        .let(::File)
        .apply {
            copyRecursively(repoDir, true)
            deleteRecursively()
        }.run {
            if (!exists()) logger.info("$name directory successfully deleted.")
            else throw IOException("$name must not exist.")
        }
    FileOperationResult.Success
} catch (e: Exception) {
    FileOperationResult.Failure(e.message ?: "An error occurred during file copy.")
}

/*=================================================================================*/

fun initAddCommit(
    repoDir: File,
    conf: SiteConfiguration,
): RevCommit {
    //3) initialiser un repo dans le dossier cvs
    init()
        .setInitialBranch(conf.pushPage.branch)
        .setDirectory(repoDir)
        .call().run {
            if (!repository.isBare) logger.info("Repository is not bare")
            else throw Exception("Repository is bare")
            if (repository.directory.isDirectory) logger.info("Repository file is a directory")
            else throw Exception("Repository file must be a directory")
            // add remote repo:
            remoteAdd().apply {
                setName(ORIGIN)
                setUri(URIish(conf.pushPage.repo.repository))
                // you can add more settings here if needed
            }.call()
            //4) ajouter les fichiers du dossier cvs à l'index
            add().addFilepattern(".").call()
            //5) commit
            return commit().setMessage(conf.pushPage.message).call()
        }
}

/*=================================================================================*/


fun initAddCommitForMaquette(
    repoDir: File,
    conf: SiteConfiguration,
): RevCommit {
    //3) initialiser un repo dans le dossier cvs
    init()
        .setInitialBranch(conf.pushMaquette.branch)
        .setDirectory(repoDir)
        .call().run {
            if (!repository.isBare) logger.info("Repository is not bare")
            else throw Exception("Repository is bare")
            if (repository.directory.isDirectory) logger.info("Repository file is a directory")
            else throw Exception("Repository file must be a directory")
            // add remote repo:
            remoteAdd().apply {
                setName(ORIGIN)
                setUri(URIish(conf.pushMaquette.repo.repository))
                // you can add more settings here if needed
            }.call()
            //4) ajouter les fichiers du dossier cvs à l'index
            add().addFilepattern(".").call()
            //5) commit
            return commit().setMessage(conf.pushMaquette.message).call()
        }
}


/*=================================================================================*/


fun push(repoDir: File, conf: SiteConfiguration): MutableIterable<PushResult>? =
    FileRepositoryBuilder().setGitDir(
        "${repoDir.absolutePath}${getDefault().separator}.git".let(::File)
    ).readEnvironment()
        .findGitDir()
        .setMustExist(true)
        .build()
        .also {
            it.config.apply {
                getString(
                    REMOTE,
                    ORIGIN,
                    conf.pushPage.repo.repository
                )
            }.save()
            if (!it.isBare) logger.info("$it repository is not bare.")
            else throw Exception("$it must not be bare.")
        }.let(::Git).run {
            // push to remote:
            push().apply {
                setCredentialsProvider(
                    UsernamePasswordCredentialsProvider(
                        conf.pushPage.repo.credentials.username,
                        conf.pushPage.repo.credentials.password
                    )
                )
                //you can add more settings here if needed
                remote = ORIGIN
                isForce = true
            }.call()
        }

/*=================================================================================*/
fun pushMaquette(repoDir: File, conf: SiteConfiguration): MutableIterable<PushResult>? =
    FileRepositoryBuilder().setGitDir(
        "${repoDir.absolutePath}${getDefault().separator}.git".let(::File)
    ).readEnvironment()
        .findGitDir()
        .setMustExist(true)
        .build()
        .also {
            it.config.apply {
                getString(
                    REMOTE,
                    ORIGIN,
                    conf.pushMaquette.repo.repository
                )
            }.save()
            if (!it.isBare) logger.info("$it repository is not bare.")
            else throw Exception("$it must not be bare.")
        }.let(::Git).run {
            // push to remote:
            push().apply {
                setCredentialsProvider(
                    UsernamePasswordCredentialsProvider(
                        conf.pushMaquette.repo.credentials.username,
                        conf.pushMaquette.repo.credentials.password
                    )
                )
                //you can add more settings here if needed
                remote = ORIGIN
                isForce = true
            }.call()
        }

/*=================================================================================*/


fun pushPages(
    destPath: () -> String,
    pathTo: () -> String
) = pathTo()
    .run(::createRepoDir)
    .let { it: File ->
        copyBakedFilesToRepo(destPath(), it)
            .takeIf { it is FileOperationResult.Success }
            ?.run {
                initAddCommit(it, localConf)
                push(it, localConf)
                it.deleteRecursively()
                destPath().let(::File).deleteRecursively()
            }
    }


/*=================================================================================*/
fun pushMaquette(
    destPath: () -> String,
    pathTo: () -> String
) = pathTo()
    .run(::createRepoDir)
    .let { it: File ->
        copyBakedFilesToRepo(destPath(), it)
            .takeIf { it is FileOperationResult.Success }
            ?.run {
                initAddCommitForMaquette(it, localConf)
                pushMaquette(it, localConf)
                it.deleteRecursively()
                destPath().let(::File).deleteRecursively()
            }
    }


/*=================================================================================*/

project.tasks.wrapper {
    gradleVersion = "9.0.0"
    distributionType = BIN
}

jbake {
    srcDirName = bakeSrcPath
    destDirName = bakeDestinationDirPath
    configuration["asciidoctor.option.requires"] = "asciidoctor-diagram"
    configuration["asciidoctor.attributes"] = mapOf(
        "sourceDir" to projectDir,
        "imagesDir" to "diagrams",
        "imagesoutdir" to "${tasks.bake.get().input}/assets/diagrams"
    )
//    configuration["asciidoctor.attributes"] = arrayOf(
//        "sourceDir=${projectDir}",
//        "imagesDir=diagrams",
//        "imagesoutdir=${tasks.bake.get().input}/assets/diagrams")
}
//TODO: add readme-site-repository
tasks.register("publishSite") {
    group = "managed"
    description = "Publish site online."
    dependsOn(tasks.bake)
    doFirst { createCnameFile() }
    doLast {
        pushPages(
            destPath = { "${layout.buildDirectory.get().asFile.absolutePath}${getDefault().separator}$bakeDestinationDirPath" },
            pathTo = { "${layout.buildDirectory.get().asFile.absolutePath}${getDefault().separator}${localConf.pushPage.to}" }
        )
    }
}

/*=================================================================================*/

tasks.register("publishMaquette") {
    group = "managed"
    description = "Publish maquette site online."

    doFirst {
        val uiDir: Directory = project.layout.projectDirectory
            .dir(project.properties["maquette_path"].toString())

        logger.info("uiDir: $uiDir")

        val baked: File = project.layout.projectDirectory
            .run { "$this/build/bake" }
            .run(::File)

        if (baked.exists() && baked.isDirectory)
            if (!baked.deleteRecursively())
                throw IOException("Cannot delete directory: $baked ")
        if (baked.exists() && !baked.isDirectory)
            if (!baked.delete())
                throw IOException("Cannot delete file and should not be a file, expected to be a directory: $baked ")
        logger.info("Successfully deleted existed $baked file")

        if (!baked.mkdirs()) throw IOException("Cannot create directory: $baked")
        else logger.info("Successfully created directory: $baked")

        if (!uiDir.asFile.copyRecursively(baked, true))
            throw IOException("Cannot copy $uiDir to $baked (aimed to be pushed at ghpages).")
    }

    doLast {
        logger.info("bakeDestinationDirPath: $bakeDestinationDirPath")
        pushMaquette(
            destPath = { "${layout.buildDirectory.get().asFile.absolutePath}${getDefault().separator}$bakeDestinationDirPath" },
            pathTo = { "${layout.buildDirectory.get().asFile.absolutePath}${getDefault().separator}${localConf.pushMaquette.to}" }"
        )
    }
}
/*=================================================================================*/
----

=== Fichier `gradle/libs.versions.toml`

[source,toml]
----
[versions]
commons-io = "2.13.0"
jackson = "2.18.3"
jgit = "6.10.0.202406032230-r"
commons-lang3 = "3.14.0"
slf4j = "2.0.17"
jbake = "5.5.0"
xz = "1.10"
asciidoctorj-diagram = "3.0.1"
asciidoctorj-diagram-plantuml = "1.2025.3"
kotlin = "2.2.10"
kotlinx-serialization-json = "1.7.2"
kotlinx-coroutines-core="1.10.2"
arrow-kt = "1.2.4"
arrow-kt_jackson = "0.14.1"
deps-versions = "0.52.0"
r2dbc-postgresql = "1.0.7.RELEASE"



[libraries]
asciidoctorj-diagram = { group = "org.asciidoctor", name = "asciidoctorj-diagram", version.ref = "asciidoctorj-diagram" }
asciidoctorj-diagram-plantuml = { group = "org.asciidoctor", name = "asciidoctorj-diagram-plantuml", version.ref = "asciidoctorj-diagram-plantuml" }
jbake = { group = "org.jbake", name = "jbake-gradle-plugin", version.ref = "jbake" }
slf4j-simple = { group = "org.slf4j", name = "slf4j-simple", version.ref = "slf4j" }
xz = { group = "org.tukaani", name = "xz", version.ref = "xz" }
commons-io = { group = "commons-io", name = "commons-io", version.ref = "commons-io" }
jackson-module-kotlin = { group = "com.fasterxml.jackson.module", name = "jackson-module-kotlin" }
jackson-datatype-jsr310 = { group = "com.fasterxml.jackson.datatype", name = "jackson-datatype-jsr310", version.ref = "jackson" }
jackson-module-jsonSchema = { group = "com.fasterxml.jackson.module", name = "jackson-module-jsonSchema", version.ref = "jackson" }
jackson-dataformat-yaml = { group = "com.fasterxml.jackson.dataformat", name = "jackson-dataformat-yaml", version.ref = "jackson" }
jackson-databind-yaml = { group = "com.fasterxml.jackson.core", name = "jackson-databind", version.ref = "jackson" }
jgit-core = { group = "org.eclipse.jgit", name = "org.eclipse.jgit", version.ref = "jgit" }
jgit-archive = { group = "org.eclipse.jgit", name = "org.eclipse.jgit.archive", version.ref = "jgit" }
jgit-ssh = { group = "org.eclipse.jgit", name = "org.eclipse.jgit.ssh.jsch", version.ref = "jgit" }
commons-lang3 = { group = "org.apache.commons", name = "commons-lang3", version.ref = "commons-lang3" }
kotlin-reflect = { group = "org.jetbrains.kotlin", name = "kotlin-reflect" }
kotlin-stdlib-jdk8 = { group = "org.jetbrains.kotlin", name = "kotlin-stdlib-jdk8" }
kotlinx-coroutines-core = { group = "org.jetbrains.kotlinx", name = "kotlinx-coroutines-core", version.ref = "kotlinx-coroutines-core" }
kotlinx-serialization-json = { group = "org.jetbrains.kotlinx", name = "kotlinx-serialization-json", version.ref = "kotlinx-serialization-json" }
r2dbc-postgresql = { group = "org.postgresql", name = "r2dbc-postgresql", version.ref = "r2dbc-postgresql" }
commons-fileupload = { group = "commons-fileupload", name = "commons-fileupload", version = "1.5.0.redhat-00001" }
arrow-core = { group = "io.arrow-kt", name = "arrow-core", version.ref = "arrow-kt" }
arrow-fx-coroutines = { group = "io.arrow-kt", name = "arrow-fx-coroutines", version.ref = "arrow-kt" }
arrow-integrations-jackson-module = { group = "io.arrow-kt", name = "arrow-integrations-jackson-module", version.ref = "arrow-kt_jackson" }
reactor-kotlin-extensions = { group = "io.projectreactor.kotlin", name = "reactor-kotlin-extensions" }
kotlinx-coroutines-reactor = { group = "org.jetbrains.kotlinx", name = "kotlinx-coroutines-reactor" }
commons-collections4 = { group = "org.apache.commons", name = "commons-collections4", version = "4.5.0-M1" }
commons-collections-obsolete = { group = "commons-collections", name = "3.2.1" }
poi-ooxml = { group = "org.apache.poi", name = "poi-ooxml", version = "5.2.5" }

[plugins]
kotlin-jvm = { id = "org.jetbrains.kotlin.jvm", version.ref = "kotlin" }
kotlin-allopen = { id = "org.jetbrains.kotlin.plugin.allopen", version.ref = "kotlin" }
kotlin-noarg = { id = "org.jetbrains.kotlin.plugin.noarg", version.ref = "kotlin" }
kotlin-serialization = { id = "org.jetbrains.kotlin.plugin.serialization", version.ref = "kotlin" }
versions = { id = "com.github.ben-manes.versions", version.ref = "deps-versions" }

[bundles]
----

=== Fichier `settings.gradle.kts`

[source,kotlin]
----
@file:Suppress("UnstableApiUsage")

pluginManagement {
    buildscript {
        repositories {
            gradlePluginPortal()
            mavenCentral()
        }
    }
    plugins { id("org.jbake.site").version(extra["jbake_gradle_plugin_version"].toString()) }
}

dependencyResolutionManagement {
    repositories {
        google()
        mavenCentral()
    }
}

rootProject.name = "thymeleaf.cheroliv.com"
----

=== Fichier `managed-jbake-context.yml`

Ce fichier contient les configurations spécifiques à JBake et aux dépôts Git pour le déploiement. Les informations sensibles ont été anonymisées.

[source,yaml]
----
bake:
  srcPath: "site"
  destDirPath: "bake"
  cname: ""
pushPage:
  from: "bake"
  to: "cvs"
  repo:
    name: "ANONYMIZED_REPO_NAME_1"
    repository: "https://github.com/web-content/acme.github.io.git"
    credentials:
      username: "ANONYMIZED_USERNAME"
      password: "ANONYMIZED_PASSWORD"
  branch: "main"
  message: "ANONYMIZED_COMMIT_MESSAGE_SITE"
pushMaquette:
  from: "bake"
  to: "cvs"
  repo:
    name: "ANONYMIZED_REPO_NAME_2"
    repository: "https://github.com/web-content/acme-maquette.git"
    credentials:
      username: "ANONYMIZED_USERNAME"
      password: "ANONYMIZED_PASSWORD"
  branch: "main"
  message: "ANONYMIZED_COMMIT_MESSAGE_MAQUETTE"
----
= Intégrer TypeScript dans JBake avec Vite
@cheroliv
2025-05-28
:jbake-type: post
:jbake-status: published
:jbake-tags: jbake, typescript, vite, build
:idprefix:
:summary: Intégrer TypeScript dans JBake avec Vite
:icons: font
:sectnumlevels: 6
:sectnums:
:toc: left
:toc-title: Sommaire


JBake est un excellent générateur de site statique pour Java, mais il ne supporte pas nativement TypeScript. Dans cet article, nous allons voir comment intégrer TypeScript dans votre workflow JBake en utilisant Vite comme bundler moderne.

== Pourquoi TypeScript et Vite ?

TypeScript apporte le typage statique à JavaScript, ce qui améliore considérablement l'expérience de développement avec :

* **Détection d'erreurs à la compilation** - Plus d'erreurs silencieuses en production
* **Autocomplétion intelligente** - Votre IDE comprend mieux votre code
* **Refactoring sécurisé** - Renommage et restructuration sans casse
* **Documentation vivante** - Les types servent de documentation

Vite, de son côté, offre :

* **Démarrage ultra-rapide** - Hot Module Replacement instantané
* **Build optimisé** - Utilise Rollup pour la production
* **Configuration minimale** - Fonctionne out-of-the-box
* **Support TypeScript natif** - Pas besoin de configuration complexe

== Structure du projet

Voici l'organisation recommandée pour un projet JBake avec TypeScript :

[source]
----
mon-blog/
├── src/
│   ├── main/
│   │   └── jbake/
│   │       ├── content/          # Articles et pages
│   │       ├── templates/        # Templates Freemarker/Thymeleaf
│   │       └── assets/
│   │           ├── css/
│   │           └── images/
│   └── ts/                       # Sources TypeScript
│       ├── main.ts
│       ├── components/
│       └── utils/
├── dist/                         # JavaScript compilé
├── build/                        # Site JBake généré
├── package.json
├── vite.config.js
├── tsconfig.json
└── build.gradle
----

== Configuration initiale

=== 1. Initialisation npm

[source,bash]
----
npm init -y
npm install -D typescript vite @types/node
----

=== 2. Configuration TypeScript

Créez le fichier `tsconfig.json` :

[source,json]
----
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "strict": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "preserve"
  },
  "include": ["src/ts/**/*"],
  "exclude": ["node_modules", "dist", "build"]
}
----

=== 3. Configuration Vite

Créez le fichier `vite.config.js` :

[source,javascript]
----
import { defineConfig } from 'vite'
import { resolve } from 'path'

export default defineConfig({
  root: 'src/ts',
  build: {
    outDir: '../../dist',
    emptyOutDir: true,
    lib: {
      entry: resolve(__dirname, 'src/ts/main.ts'),
      name: 'SiteScript',
      fileName: 'main',
      formats: ['iife']
    },
    rollupOptions: {
      output: {
        assetFileNames: 'assets/[name].[ext]'
      }
    }
  },
  server: {
    port: 3001,
    proxy: {
      '/': 'http://localhost:8820'  // Proxy vers JBake serve
    }
  }
})
----

== Scripts de build

Ajoutez ces scripts dans votre `package.json` :

[source,json]
----
{
  "scripts": {
    "dev:ts": "vite",
    "build:ts": "vite build",
    "preview": "vite preview",
    "dev": "concurrently \"npm run dev:ts\" \"./gradlew jbakeServe\"",
    "build": "npm run build:ts && ./gradlew jbake"
  },
  "devDependencies": {
    "concurrently": "^7.6.0"
  }
}
----

== Intégration avec Gradle

Modifiez votre `build.gradle` pour automatiser le build TypeScript :

[source,groovy]
----
plugins {
    id 'org.jbake.site' version '5.3.0'
    id 'com.github.node-gradle.node' version '3.5.1'
}

// Configuration Node.js
node {
    download = true
    version = '18.16.0'
}

// Task pour build TypeScript
task buildTypeScript(type: NpmTask) {
    args = ['run', 'build:ts']
    inputs.dir('src/ts')
    outputs.dir('dist')
}

// Task pour installer les dépendances
task npmInstall(type: NpmTask) {
    args = ['install']
}

// Configuration JBake
jbake {
    srcDirName = 'src/main/jbake'
    destDirName = 'build'
}

// Copie des fichiers JS dans les assets JBake
task copyJavaScript(type: Copy) {
    from 'dist'
    into 'src/main/jbake/assets/js'
    dependsOn buildTypeScript
}

// Dépendances des tâches
buildTypeScript.dependsOn npmInstall
jbake.dependsOn copyJavaScript
----

== Exemple d'application TypeScript

Créez le fichier `src/ts/main.ts` :

[source,typescript]
----
interface SearchConfig {
  minLength: number;
  debounceMs: number;
  apiEndpoint: string;
}

interface SearchResult {
  items: Array<{
    title: string;
    url: string;
    excerpt: string;
  }>;
  total: number;
}

class BlogSearch {
  private config: SearchConfig;
  private searchInput: HTMLInputElement;
  private resultsContainer: HTMLElement;
  private debounceTimer?: number;

  constructor(config: Partial<SearchConfig> = {}) {
    this.config = {
      minLength: 2,
      debounceMs: 300,
      apiEndpoint: '/api/search',
      ...config
    };

    this.initializeElements();
    this.setupEventListeners();
  }

  private initializeElements(): void {
    const searchInput = document.querySelector('#search');
    const resultsContainer = document.querySelector('#search-results');

    if (!searchInput || !resultsContainer) {
      throw new Error('Required elements not found');
    }

    this.searchInput = searchInput as HTMLInputElement;
    this.resultsContainer = resultsContainer as HTMLElement;
  }

  private setupEventListeners(): void {
    this.searchInput.addEventListener('input', (event) => {
      this.handleSearchInput(event);
    });

    // Gestion de l'ESC pour fermer les résultats
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape') {
        this.clearResults();
      }
    });
  }

  private handleSearchInput(event: Event): void {
    const target = event.target as HTMLInputElement;
    const query = target.value.trim();

    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer);
    }

    this.debounceTimer = window.setTimeout(() => {
      if (query.length >= this.config.minLength) {
        this.performSearch(query);
      } else {
        this.clearResults();
      }
    }, this.config.debounceMs);
  }

  private async performSearch(query: string): Promise<void> {
    try {
      this.showLoading();

      const response = await fetch(
        `${this.config.apiEndpoint}?q=${encodeURIComponent(query)}`
      );

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const results: SearchResult = await response.json();
      this.displayResults(results);

    } catch (error) {
      console.error('Search failed:', error);
      this.showError('Erreur lors de la recherche');
    }
  }

  private showLoading(): void {
    this.resultsContainer.innerHTML = `
      <div class="search-loading">
        <div class="spinner"></div>
        <span>Recherche en cours...</span>
      </div>
    `;
    this.resultsContainer.classList.add('visible');
  }

  private displayResults(results: SearchResult): void {
    if (results.items.length === 0) {
      this.resultsContainer.innerHTML = `
        <div class="search-empty">
          <p>Aucun résultat trouvé</p>
        </div>
      `;
      return;
    }

    const resultsList = results.items
      .map(item => `
        <article class="search-result">
          <h3><a href="${this.escapeHtml(item.url)}">${this.escapeHtml(item.title)}</a></h3>
          <p>${this.escapeHtml(item.excerpt)}</p>
        </article>
      `)
      .join('');

    this.resultsContainer.innerHTML = `
      <div class="search-results">
        <header class="search-header">
          <span class="search-count">${results.total} résultat(s)</span>
          <button class="search-close" onclick="blogSearch.clearResults()">×</button>
        </header>
        <div class="search-list">
          ${resultsList}
        </div>
      </div>
    `;

    this.resultsContainer.classList.add('visible');
  }

  private showError(message: string): void {
    this.resultsContainer.innerHTML = `
      <div class="search-error">
        <p>${this.escapeHtml(message)}</p>
      </div>
    `;
    this.resultsContainer.classList.add('visible');
  }

  public clearResults(): void {
    this.resultsContainer.innerHTML = '';
    this.resultsContainer.classList.remove('visible');
  }

  private escapeHtml(text: string): string {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
}

// Initialisation globale
declare global {
  interface Window {
    blogSearch: BlogSearch;
  }
}

// Démarrage de l'application
document.addEventListener('DOMContentLoaded', () => {
  window.blogSearch = new BlogSearch({
    apiEndpoint: '/search.json',
    minLength: 3,
    debounceMs: 250
  });
});
----

== Intégration dans les templates

Dans vos templates JBake (Freemarker exemple), référencez le JavaScript compilé :

[source,html]
----
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8">
    <title>${content.title!"Mon Blog"}</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/css/main.css">
</head>
<body>
    <header>
        <nav>
            <input type="search" id="search" placeholder="Rechercher...">
            <div id="search-results" class="search-results-container"></div>
        </nav>
    </header>

    <main>
        ${content.body}
    </main>

    <!-- Script TypeScript compilé -->
    <script src="/js/main.iife.js"></script>
</body>
</html>
----

== Workflow de développement

=== Mode développement

Pour le développement avec hot reload :

[source,bash]
----
# Terminal 1 : JBake en mode serve
./gradlew jbakeServe

# Terminal 2 : Vite en mode dev
npm run dev:ts
----

Ou plus simplement :

[source,bash]
----
npm run dev
----

=== Build de production

[source,bash]
----
npm run build
----

Cette commande :

1. Compile le TypeScript avec Vite
2. Copie les fichiers JS dans les assets JBake
3. Lance la génération du site par JBake

== Ajout de librairies

Vous pouvez facilement ajouter des librairies TypeScript :

[source,bash]
----
# Utilitaires de manipulation
npm install lodash-es
npm install @types/lodash-es

# Validation de données
npm install zod

# Gestion des dates
npm install date-fns
----

Puis les utiliser dans votre code :

[source,typescript]
----
import { debounce } from 'lodash-es';
import { z } from 'zod';
import { format } from 'date-fns';

const ArticleSchema = z.object({
  title: z.string(),
  date: z.string(),
  tags: z.array(z.string())
});

type Article = z.infer<typeof ArticleSchema>;
----

== Bonnes pratiques

=== Organisation du code

* **Séparez les responsabilités** - Un fichier par composant/fonctionnalité
* **Utilisez des interfaces** - Définissez les contrats de vos APIs
* **Préférez la composition** - Plutôt que l'héritage complexe

=== Performance

* **Lazy loading** - Chargez les modules à la demande
* **Tree shaking** - Vite élimine automatiquement le code inutilisé
* **Code splitting** - Séparez le code critique du reste

[source,typescript]
----
// Chargement dynamique
const loadSearchModule = async () => {
  const { BlogSearch } = await import('./components/BlogSearch');
  return new BlogSearch();
};
----

=== Configuration avancée

Pour des besoins spécifiques, vous pouvez étendre la configuration Vite :

[source,javascript]
----
// vite.config.js
export default defineConfig({
  plugins: [
    // Plugin pour les Web Workers
    // Plugin pour les Progressive Web Apps
  ],
  build: {
    target: 'es2020',
    sourcemap: true,
    minify: 'terser'
  }
})
----

== Conclusion

L'intégration de TypeScript dans JBake via Vite vous offre le meilleur des deux mondes : la robustesse du générateur de site statique Java et la modernité du développement frontend TypeScript.

Cette approche vous permet de :

* Développer avec un excellent DX (Developer Experience)
* Bénéficier du typage statique pour réduire les bugs
* Utiliser l'écosystème npm moderne
* Maintenir des performances optimales en production

Le workflow proposé s'intègre naturellement dans votre processus de build existant et peut être étendu selon vos besoins spécifiques.

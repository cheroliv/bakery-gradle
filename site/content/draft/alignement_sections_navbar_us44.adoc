= Alignement Précis des Sections sous la Barre de Navigation Fixe (US-44)
:author: cheroliv
:date: 2025-09-04
:tags: web, frontend, javascript, css, bootstrap, accessibilité, ux, jbake, asciidoc
:status: published
:type: post
:toc: left
:summary: Cet article explore la problématique de l'alignement des sections sous une, barre de navigation fixe sur les petits écrans, les tentatives de résolution, et la solution finale mise en place pour garantir un alignement parfait et une meilleure expérience utilisateur.
:slug: alignement-sections-navbar-us44

// PlantUML diagram for Use Case
[plantuml, use-case-alignement, svg]
----
@startuml
left to right direction
actor "Utilisateur" as user

rectangle "Navigation du Site" {
  usecase "Cliquer sur un lien de navigation" as click_link
  usecase "Ouvrir le menu burger (petit écran)" as open_burger
  usecase "Fermer le menu burger (petit écran)" as close_burger
  usecase "Défiler vers une section" as scroll_section
  usecase "Voir la section alignée" as see_aligned
}

user --> open_burger
user --> click_link
open_burger --> close_burger : inclut
click_link --> scroll_section
scroll_section --> see_aligned
@enduml
----

== Introduction

L'expérience utilisateur sur les sites web modernes exige une navigation fluide et intuitive, particulièrement sur les appareils mobiles. L'une des problématiques courantes est l'alignement précis des sections de contenu sous une barre de navigation (navbar) fixe. Cette User Story (US-44) visait à résoudre ce problème persistant sur notre site, où le défilement vers une section après avoir cliqué sur un lien de menu (surtout depuis le menu burger sur petit écran) laissait la section partiellement masquée sous la navbar.

Cet article explore la problématique, les tentatives de résolution, et la solution finale mise en place pour garantir un alignement parfait, offrant ainsi une meilleure accessibilité et une expérience utilisateur améliorée.

== La Problématique : Un Décalage Persistant

Imaginez un utilisateur sur son smartphone, naviguant sur votre site. Il ouvre le menu burger, clique sur "À propos", et s'attend à voir le début de la section "À propos" juste en dessous de la barre de navigation. Cependant, la section apparaît décalée, son titre étant partiellement ou totalement masqué par la navbar fixe.

Ce comportement est frustrant et nuit à l'accessibilité. La cause principale réside souvent dans la difficulté de synchroniser le calcul de la hauteur de la navbar (qui peut varier, notamment avec l'ouverture/fermeture du menu burger) avec le mécanisme de défilement du navigateur.

== Tentatives de Résolution et Leurs Défis

Nous avons exploré plusieurs pistes pour résoudre ce problème.

=== Approche 1 : Décalage JavaScript avec `setTimeout`

La première tentative a consisté à utiliser JavaScript pour calculer la hauteur de la navbar et ajuster la position de défilement. Un délai (`setTimeout`) était ajouté après la fermeture du menu burger pour laisser le temps à l'animation de se terminer et à la navbar de retrouver sa taille "fixe".

[source,javascript]
----
// Extrait de script.js (ancienne version)
class SmoothScrollWithOffset {
    // ...
    handleAnchorClick(event) {
        // ...
        if (targetElement) {
            event.preventDefault();
            const navbarCollapse = this.navbar.querySelector('.navbar-collapse');
            const isMobileMenuOpen = navbarCollapse && navbarCollapse.classList.contains('show');

            const performScroll = () => {
                const navbarHeight = this.navbar ? this.navbar.offsetHeight : 0; // <1>
                const elementPosition = targetElement.getBoundingClientRect().top + window.scrollY;
                const offsetPosition = elementPosition - navbarHeight;

                window.scrollTo({
                    top: offsetPosition,
                    behavior: 'smooth'
                });
            };

            if (isMobileMenuOpen) {
                navbarCollapse.addEventListener('hidden.bs.collapse', () => {
                    setTimeout(performScroll, 300); // <2>
                }, { once: true });
            } else {
                performScroll();
            }
        }
    }
}
----
<1> `this.navbar.offsetHeight` était utilisé pour obtenir la hauteur de la navbar.
<2> Un délai de 300ms était appliqué après la fermeture du menu burger.

*Problème :* Malgré le délai, `this.navbar.offsetHeight` renvoyait souvent une valeur incorrecte (par exemple, `458px` ou `442px` comme observé dans les logs), correspondant à la hauteur de la navbar *avec le menu burger encore partiellement ou totalement déployé*, et non à la hauteur de la barre fixe seule. Cela entraînait un décalage persistant.

=== Approche 2 : `scroll-margin-top` avec `scrollIntoView` (tentative initiale)

Une approche plus moderne consiste à utiliser la propriété CSS `scroll-margin-top` en combinaison avec la méthode JavaScript `scrollIntoView()`.

[source,css]
----
/* Extrait de styles.css (ancienne tentative) */
section {
    padding: 5rem 0;
    scroll-margin-top: var(--navbar-height); // <1>
}
----
<1> La variable CSS `--navbar-height` était censée définir le décalage.

[source,javascript]
----
// Extrait de script.js (ancienne tentative)
class SmoothScrollWithOffset {
    // ...
    handleAnchorClick(event) {
        // ...
        if (targetElement) {
            event.preventDefault();
            const navbarCollapse = this.navbar.querySelector('.navbar-collapse');
            const isMobileMenuOpen = navbarCollapse && navbarCollapse.classList.contains('show');

            if (isMobileMenuOpen) {
                navbarCollapse.addEventListener('hidden.bs.collapse', () => {
                    targetElement.scrollIntoView({ behavior: 'smooth' }); // <1>
                }, { once: true });
            } else {
                targetElement.scrollIntoView({ behavior: 'smooth' });
            }
        }
    }
}
----
<1> `scrollIntoView` est utilisé, s'appuyant sur `scroll-margin-top`.

*Problème :* Bien que cette approche soit plus idiomatique, elle ne résolvait pas complètement le problème sur tous les navigateurs (notamment Chromium). Le `scroll-margin-top` semblait ne pas être appliqué correctement ou à temps, ou la variable `--navbar-height` n'était pas toujours à jour au moment du défilement.

== La Cause Profonde : Une Hauteur de Navbar Incohérente

L'analyse des logs console a révélé que la hauteur de la navbar (`this.navbar.offsetHeight`) était souvent surévaluée, car elle incluait la hauteur du contenu du menu burger (`.navbar-collapse`) même après que l'animation de fermeture ait commencé. Le `ResizeObserver` dans `NavbarHeightUpdater` capturait la hauteur totale de l'élément `<nav>` qui, sur mobile, englobe à la fois la barre supérieure fixe et le contenu déroulant.

// PlantUML diagram for Component Diagram
[plantuml, component-alignement, svg]
----
@startuml
component "Navigateur Web" as Browser {
  component "HTML Document" as HTML
  component "CSS Engine" as CSS
  component "JavaScript Engine" as JS
}

component "Barre de Navigation (Navbar)" as Navbar
component "Sections du Contenu" as Sections
component "SmoothScrollWithOffset (JS)" as SmoothScroll
component "NavbarHeightUpdater (JS)" as NavbarUpdater

HTML <--> Navbar
HTML <--> Sections
HTML <--> CSS : Applique styles
HTML <--> JS : Exécute scripts

JS --> SmoothScroll
JS --> NavbarUpdater

NavbarUpdater .> CSS : Met à jour --navbar-height
SmoothScroll .> CSS : Lit --navbar-height
SmoothScroll .> Sections : Défile vers
Navbar <.down. NavbarUpdater : Observe hauteur
@enduml
----

== La Solution : Précision et Cohérence

La résolution a nécessité une combinaison de modifications ciblées en CSS et JavaScript pour garantir que la hauteur de la barre de navigation fixe soit toujours correctement prise en compte.

=== Étape 1 : Définition d'une Variable CSS pour la Hauteur de la Navbar

Nous avons introduit une variable CSS `--navbar-height` dans `:root` pour centraliser la gestion de cette hauteur.

[source,css]
----
/* Extrait de site/assets/css/styles.css */
:root {
    /* Light Theme Variables */
    --navbar-height: 80px; /* Default height, will be updated by JS */
    --bg-primary: #ffffff;
    // ...
}
----

=== Étape 2 : Application de `scroll-margin-top` aux Sections

La propriété `scroll-margin-top` a été appliquée à toutes les sections pour créer un décalage de défilement natif, utilisant la variable `--navbar-height`.

[source,css]
----
/* Extrait de site/assets/css/styles.css */
section {
    padding: 5rem 0;
    scroll-margin-top: var(--navbar-height); // <1>
}
----
<1> Le décalage est désormais géré par CSS, en se basant sur la variable.

=== Étape 3 : `NavbarHeightUpdater` Affiné pour une Hauteur Précise

La classe `NavbarHeightUpdater` a été modifiée pour calculer la hauteur de la navbar de manière plus robuste. Au lieu de `this.navbar.offsetHeight` (qui inclut le menu déroulant), elle cible des éléments spécifiques de la barre fixe, comme `.navbar-brand` ou `.navbar-toggler`, pour obtenir une hauteur plus stable.

[source,javascript]
----
// Extrait de site/assets/js/script.js
class NavbarHeightUpdater {
    constructor(navbar) {
        this.navbar = navbar;
        this.init();
    }

    init() {
        if (!this.navbar || !('ResizeObserver' in window)) return;
        const resizeObserver = new ResizeObserver(() => this.updateHeight());
        resizeObserver.observe(this.navbar);
        this.updateHeight(); // Initial update
    }

    updateHeight() {
        const brandElement = this.navbar.querySelector('.navbar-brand'); // <1>
        let actualNavbarHeight = 0;

        if (brandElement) {
            actualNavbarHeight = brandElement.offsetHeight;
        }
        // Fallback if brandElement is not found, though it should always exist
        else {
            const togglerElement = this.navbar.querySelector('.navbar-toggler');
            if (togglerElement) {
                actualNavbarHeight = togglerElement.offsetHeight;
            }
        }

        const newHeight = `${actualNavbarHeight}px`;
        document.documentElement.style.setProperty('--navbar-height', newHeight); // <2>
        console.log('NavbarHeightUpdater - New --navbar-height set to:', newHeight, 'from element:', brandElement); // Debugging
    }
}
----
<1> Ciblage de `.navbar-brand` pour une hauteur plus fiable.
<2> Mise à jour de la variable CSS `--navbar-height`.

=== Étape 4 : `SmoothScrollWithOffset` Simplifié

La classe `SmoothScrollWithOffset` a été simplifiée pour s'appuyer entièrement sur le comportement natif de `scrollIntoView()` et la propriété `scroll-margin-top` gérée par CSS. Le délai `setTimeout` a été supprimé, car la gestion du décalage est désormais déléguée au CSS.

[source,javascript]
----
// Extrait de site/assets/js/script.js
class SmoothScrollWithOffset {
    constructor(navbarSelector = '.navbar') {
        this.navbar = document.querySelector(navbarSelector);
        this.init();
    }

    init() {
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', this.handleAnchorClick.bind(this));
        });
    }

    handleAnchorClick(event) {
        const href = event.currentTarget.getAttribute('href');
        if (href === '#' || href === '#home') {
            event.preventDefault();
            window.scrollTo({ top: 0, behavior: 'smooth' });
            return;
        }

        const targetId = href.substring(1);
        const targetElement = document.getElementById(targetId);

        if (targetElement) {
            event.preventDefault();
            const navbarCollapse = this.navbar.querySelector('.navbar-collapse');
            const isMobileMenuOpen = navbarCollapse && navbarCollapse.classList.contains('show');

            if (isMobileMenuOpen) {
                // Attendre la fin de l'animation de fermeture du menu burger
                navbarCollapse.addEventListener('hidden.bs.collapse', () => {
                    targetElement.scrollIntoView({ behavior: 'smooth' }); // <1>
                }, { once: true });
            } else {
                targetElement.scrollIntoView({ behavior: 'smooth' }); // <1>
            }
        }
    }
}
----
<1> `scrollIntoView` est utilisé, le décalage étant géré par `scroll-margin-top` en CSS.

// PlantUML diagram for Sequence Diagram
[plantuml, sequence-alignement, svg]
----
@startuml
autonumber
actor "Utilisateur" as User
participant "Navigateur" as Browser
participant "Navbar (HTML/CSS)" as Navbar
participant "NavbarHeightUpdater (JS)" as Updater
participant "SmoothScrollWithOffset (JS)" as Scroller
participant "Section Cible (HTML)" as TargetSection

User -> Browser: Redimensionne à petit écran
Browser -> Navbar: Affiche menu burger
Browser -> Updater: Notifie changement de taille (ResizeObserver)
Updater -> Browser: Calcule hauteur Navbar (e.g., .navbar-brand.offsetHeight)
Updater -> Browser: Définit CSS variable --navbar-height
Browser -> Navbar: Applique --navbar-height (via scroll-margin-top)

User -> Browser: Clique sur "À propos" (lien dans menu burger)
Browser -> Navbar: Ferme le menu burger (animation)
Browser -> Scroller: Déclenche handleAnchorClick
Scroller -> TargetSection: scrollIntoView({ behavior: 'smooth' })
Browser -> TargetSection: Défile avec offset (scroll-margin-top)
User -> Browser: Voit "À propos" aligné sous la Navbar
@enduml
----

== Conclusion

La résolution de l'US-44 a mis en lumière l'importance d'une approche combinée CSS et JavaScript pour gérer les décalages de défilement avec des éléments fixes. En utilisant `scroll-margin-top` et en assurant une mise à jour précise de la variable CSS `--navbar-height` via un `ResizeObserver` ciblant un élément stable de la navbar, nous avons obtenu un alignement parfait sur tous les navigateurs. Cette solution améliore significativement l'expérience utilisateur et l'accessibilité du site, garantissant que le contenu est toujours visible et bien positionné.

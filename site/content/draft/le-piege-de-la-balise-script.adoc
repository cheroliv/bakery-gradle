= HTML & Balises Auto-Fermantes : Le Guide Complet Pour Éviter la Page Blanche
CherOliv <cheroliv@cheroliv.com>
:jbake-status: published
:jbake-type: post
:jbake-tags: html, javascript, webdev, best-practices, frontend, debugging
:jbake-date: 2025-08-29
:jbake-summary: Une analyse approfondie de la raison pour laquelle les balises auto-fermantes comme <script/> cassent le HTML5, les autres balises concernées, et une checklist de débogage pour diagnostiquer ce problème courant.

Imaginez la scène : vous ajoutez une ligne de code, une simple balise <script> pour intégrer une bibliothèque. Vous rafraîchissez votre navigateur et... la page est blanche. Ou pire, seule une partie s'affiche, sans CSS ni interactivité. Vous inspectez le code source, tout semble correct. Pourtant, la console crie des erreurs cryptiques et l'inspecteur DOM montre une structure HTML sens dessus dessous.

Ce cauchemar, de nombreux développeurs l'ont vécu. La cause est souvent une erreur de syntaxe minuscule mais aux conséquences dévastatrices : l'utilisation d'une balise auto-fermante (<script ... />) là où le HTML5 l'interdit formellement.

Cet article est un guide complet pour comprendre *pourquoi* cette erreur se produit, quelles autres balises sont concernées, et comment la diagnostiquer et la corriger efficacement.

== L'Illusion de Logique : L'Héritage de JSX et XHTML

Pour un développeur web moderne, l'erreur est compréhensible. Nous passons nos journées dans des environnements comme React (JSX) ou Vue, où la syntaxe XML-esque est la norme. Dans ces mondes, une balise sans enfant est une balise auto-fermante. C'est plus propre, plus concis.

.Syntaxe *correcte* en JSX (React)
[source,jsx]
----
function MyApp() {
  return (
    <div>
      <h1>Mon App</h1>
      <script src="mon-script.js" /> {/* Totalement valide ici */}
    </div>
  );
}
----

Le piège se referme lorsque nous revenons au HTML pur. Nous gardons nos réflexes et écrivons ce qui semble être du code propre, sans réaliser que nous violons une règle fondamentale du parsing HTML5.

== Le Cœur du Problème : Le Parser HTML5 n'est pas un Parser XML

La distinction clé réside dans la manière dont un navigateur lit le HTML. Il n'utilise pas un analyseur XML strict, mais un algorithme de parsing HTML5 conçu pour être incroyablement permissif. Son but n'est pas de rejeter un document mal formé, mais de faire de son mieux pour l'interpréter. C'est cette "tolérance" qui cause ici le comportement inattendu.

=== Les Éléments "Void" : Les Seules Exceptions

En HTML5, seule une liste finie et bien définie d'éléments est considérée comme "void" (vide). Ces éléments ne peuvent, par définition, contenir aucun contenu ou balise enfant.
Pour eux, la balise fermante est non seulement optionnelle, mais interdite.

La liste inclut : `area`, `base`, `br`, `col`, `embed`, `hr`, `img`, `input`, `link`, `meta`, `param`, `source`, `track`, `wbr`.

Pour ces balises, écrire `<img src="..." />` est toléré par le navigateur pour des raisons de compatibilité, mais la forme canonique est simplement `<img src="...">`.

=== Les Éléments Normaux : La Règle de la Double Balise

Toute balise qui n'est pas dans la liste "void" est conçue pour pouvoir contenir du texte ou d'autres éléments. Pour le parser HTML5, une telle balise *doit* avoir une balise fermante explicite (`</nomdelabalise>`).

**`<script>` fait partie de cette catégorie.** Même si elle charge un fichier externe via `src` et que son contenu est "visuellement" vide, le parser la considère comme une balise qui *pourrait* contenir du code. Elle doit donc être fermée.

== L'Effet Domino : Comment le Parser Déraille Vraiment

Voyons, étape par étape, ce qui se passe dans la tête du navigateur lorsqu'il rencontre le code problématique.

.Le code qui casse tout
[source,html]
----
<body>
    <h1>Mon Super Site</h1>
    <script src="mon-script.js"/>
    <p>Ce paragraphe ne s'affichera jamais.</p>
    <footer>Pied de page invisible</footer>
</body>
----

1.  **Ligne 2 :** Le parser lit `<h1>` et `</h1>`. Tout va bien.
2.  **Ligne 3 :** Il lit `<script src="mon-script.js"/>`.
    *   Il reconnaît l'ouverture `<script ...>`.
    *   Il entre en "mode parsing de script".
    *   Il voit le `/` final. **Il l'ignore.** Pour lui, ce n'est qu'un caractère invalide dans la déclaration de la balise, pas un signal de fermeture.
3.  **Le parser est maintenant "affamé" :** Il attend une seule et unique chose pour arrêter de lire le contenu du script : la chaîne de caractères `</script>`.
4.  **Ligne 4, 5, 6... :** Tout ce qui suit (`<p>...`, `<footer>...`, `</body>`) est interprété non pas comme du HTML, mais comme le contenu textuel de la balise `<script>` ouverte à la ligne 3.
5.  **Fin du fichier :** Le parser atteint la fin du document sans jamais avoir trouvé de `</script>`. Il termine son travail, laissant une structure DOM complètement cassée.

Le diagramme suivant illustre cette "voracité" du parser.

[plantuml, html-parsing-logic, svg]
----
@startuml
skinparam componentStyle uml2
title "Logique de Parsing HTML5 face à <script/>"

rectangle "Code Source HTML" {
  label "<h1>Titre</h1>" as L1
  label "<script src='...'/>" as L2
  label "<p>Paragraphe</p>" as L3
  label "<footer>Pied</footer>" as L4
}

rectangle "Interprétation du Parser" {
  node "Début du parsing" as Start
  node "Lit <h1>...</h1>" as H1
  node "Lit <script...>" as ScriptOpen
  node "IGNORE le '/' final" as IgnoreSlash
  node "Considère TOUT ce qui suit\ncomme du contenu JavaScript" as Greedy
  node "Atteint la fin du fichier\nSANS trouver </script>" as EOF

  Start -> H1
  H1 -> ScriptOpen
  ScriptOpen -> IgnoreSlash
  IgnoreSlash -> Greedy
  Greedy -> EOF
}

L1 -> H1
L2 -> ScriptOpen
L3 --> Greedy
L4 --> Greedy
@enduml
----

== Au-delà de `<script>` : Les Autres Pièges Courants

Cette erreur ne se limite pas à la balise `<script>`. Toute balise non-"void" utilisée avec une syntaxe auto-fermante provoquera des problèmes de rendu similaires, bien que souvent moins catastrophiques.

.Exemples d'autres erreurs fréquentes
[source,html]
----
<!-- Incorrect : Le parser va chercher une balise </textarea> -->
<textarea name="comment"/>

<!-- Incorrect : Le parser va "manger" le contenu suivant -->
<div class="container"/>

<!-- Incorrect : Le parser va chercher une balise </iframe> -->
<iframe src="..."/>
----

== Checklist de Débogage : Comment Repérer l'Erreur

Votre page est blanche ou cassée ? Suivez ces étapes :

1.  **Inspectez l'onglet `Elements` (ou `Inspecteur`) des outils de développement (F12).** C'est l'indice le plus flagrant. Vous verrez probablement votre balise `<p>` et votre `<footer>` imbriquées à l'intérieur de la balise `<script>`. Le HTML affiché ici n'est pas votre code source, mais le DOM que le navigateur a réussi à construire.
2.  **Regardez la Console.** Vous y verrez peut-être des erreurs comme `Uncaught SyntaxError: Unexpected token '<'`. C'est le moteur JavaScript qui se plaint d'avoir reçu du HTML (`<p>`) à exécuter.
3.  **Utilisez un Validateur HTML.** Copiez-collez votre code dans un validateur en ligne comme le [W3C Validator](https://validator.w3.org/). Il identifiera immédiatement l'erreur comme une "Stray self-solidus" (barre oblique auto-fermante errante) et vous signalera l'absence de balise fermante.

== La Règle d'Or : Soyez Explicite

La solution est simple et s'applique à toutes les balises non-"void".

**Fournissez toujours une balise fermante explicite.**

.La syntaxe correcte et robuste
[source,html]
----
<script src="mon-script.js"></script>
<textarea name="comment"></textarea>
<div class="container"></div>
<iframe src="..."></iframe>
----

Même si la balise est vide (`<div></div>`), cette syntaxe est la seule garantie d'un parsing correct et prévisible sur tous les navigateurs.

== Conclusion

La transition entre les syntaxes de type JSX/XML et le HTML pur est une source fréquente d'erreurs subtiles. Comprendre que le parser HTML5 privilégie l'interprétation à la validation stricte est la clé pour déjouer ces pièges. En retenant la courte liste des éléments "void" et en appliquant la règle de la double balise pour tous les autres, vous vous assurerez des pages robustes et éviterez des heures de débogage frustrant.
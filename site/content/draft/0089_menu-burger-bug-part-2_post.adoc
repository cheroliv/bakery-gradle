= L'Enfer du Tatônnement : Quand le Remède est Pire que le Mal
:jbake-type: post
:jbake-status: draft
:jbake-tags: developpement, web, bootstrap, javascript, ux, ui, responsive, scrumban, gemini
:jbake-title: L'Enfer du Tatônnement - Quand le Remède est Pire que le Mal
:jbake-date: 2025-09-07
:source-highlighter: pygments
:icons: font

Dans le premier article, nous avons identifié un bug de mise en page sur notre menu de navigation et implémenté une solution JavaScript qui semblait élégante. Ce deuxième article raconte la suite de l'histoire : comment ce "correctif" a déclenché une cascade de régressions, nous forçant à remettre en question notre approche et à admettre une vérité fondamentale sur l'utilisation des frameworks.

---

== Le Mirage de la Solution Facile

Nous étions restés sur un sentiment de victoire. Le script `DynamicNavbarBreakpoint`, présenté dans l'article précédent, fonctionnait à merveille. Le menu burger apparaissait précisément au bon moment, empêchant tout passage à la ligne disgracieux. La User Story `US-40` était considérée comme "terminée".

Mais la satisfaction fut de courte durée. Très vite, des effets de bord étranges ont commencé à se manifester lors de manipulations plus complexes que le simple redimensionnement lent de la fenêtre. La solution qui semblait si robuste n'était en réalité qu'un château de cartes.

== La Valse des Régressions (BUG-46)

Les problèmes étaient sporadiques mais suffisamment irritants pour être inacceptables. Plutôt que de les traiter comme des "glitches", nous les avons formalisés en un bug unique dans notre backlog, `BUG-46`, pour analyser la cause racine plutôt que de panser les plaies une par une.

Les symptômes étaient les suivants :

1.  **Le sélecteur de thème était éjecté :** Lors de la transition vers le mode burger, le sélecteur de thème, dernier élément de la barre de navigation, était parfois poussé hors de l'écran, devenant inaccessible.
2.  **Un état "flottant" instable :** À certaines résolutions, le menu se retrouvait dans un état intermédiaire, ni complètement étendu, ni proprement réduit en burger. Il "flickrait", hésitant entre les deux états, créant une expérience visuelle très perturbante.
3.  **Des problèmes d'alignement :** Une fois le menu burger ouvert, les liens n'étaient pas toujours alignés à gauche comme attendu. Ils semblaient conserver une partie du style du menu étendu, créant un rendu incohérent.

Chaque tentative de corriger l'un de ces points semblait en aggraver un autre. Nous étions entrés dans l'enfer du tâtonnement.

== Le Conflit Fondamental : Se Battre Contre le Framework

Le cœur du problème n'était pas dans notre implémentation, mais dans notre philosophie. **Nous nous battions contre Bootstrap au lieu de travailler avec lui.**

Notre script et le JavaScript interne de Bootstrap se livraient une guerre pour le contrôle du DOM. Le diagramme de séquence ci-dessous illustre ce conflit :

[plantuml, format=svg, id=diag-logic-2, width=800px]
....
@startuml
title Conflit de Contrôle entre le Script Personnalisé et Bootstrap

actor Utilisateur
participant "Notre Script (DynamicNavbarBreakpoint)" as Script
participant "Bootstrap JS (Collapse Plugin)" as Bootstrap

Utilisateur -> Navigateur: Redimensionne la fenêtre
activate Script

Script -> Script: Détecte un passage à la ligne
Script -> DOM: Supprime `.navbar-expand-lg`
note right: Notre script dit : "Réduis-toi !"

Bootstrap -> DOM: Détecte la suppression de la classe
Bootstrap -> DOM: Applique les classes `.collapsing` puis `.collapse`
note right: Bootstrap obéit et lance son animation.

... Pendant ce temps, au même point de rupture ...

Bootstrap -> Bootstrap: Le breakpoint `lg` natif est atteint.
Bootstrap -> DOM: Tente de gérer l'état `.collapse`
note right: Bootstrap dit : "C'est mon travail !"

Script -> Script: Le redimensionnement continue, plus de passage à la ligne.
Script -> DOM: Ré-ajoute `.navbar-expand-lg`
note right: Notre script dit : "Étends-toi !"

Bootstrap -> DOM: Détecte l'ajout de la classe
Bootstrap -> DOM: Supprime les classes `.collapse` et `.show`
note right: Bootstrap obéit à nouveau.

note over Script, Bootstrap: **RACE CONDITION !**\nLes deux scripts se battent pour ajouter/supprimer\nles mêmes classes, créant le "flicker".

deactivate Script
@enduml
....

Notre erreur fondamentale était de micro-gérer un composant dont l'état est déjà entièrement géré par le framework. La barre de navigation Bootstrap est une "machine à états" sophistiquée. Elle sait quand elle doit être étendue, quand elle doit s'effondrer, et comment animer la transition entre les deux. En manipulant directement ses classes pour forcer un comportement, nous court-circuitions sa logique interne, créant un état imprévisible.

== Le Moment "Eurêka" : Et si on Lisait (Vraiment) la Doc ?

Après plusieurs heures de débogage infructueux, à ajouter des `console.log` et des `!important` en CSS (le signe universel qu'on a perdu le contrôle), le constat était sans appel : cette approche était une impasse.

Le tournant est venu d'un retour aux sources. Frustré, j'ai arrêté de "patcher" le code et j'ai ouvert la documentation de la Navbar de Bootstrap 5 pour la relire, non pas en diagonale, mais en analysant chaque classe et chaque option.

Et la clé était là, écrite noir sur blanc. Le comportement responsive de la barre de navigation est entièrement piloté par une seule et unique classe : `.navbar-expand-{breakpoint}` (par exemple, `.navbar-expand-lg`).

-   **Quand cette classe est présente**, la barre de navigation tente de s'étendre et affiche son contenu.
-   **Quand cette classe est absente**, la barre de navigation se réduit et cache son contenu derrière un bouton "burger".

L'eurêka fut de réaliser que notre script n'avait pas besoin de *recréer* la logique de réduction du menu. Il avait juste besoin de dire à Bootstrap *quand* le faire.

== Conclusion : Vers une Solution Élégante

La prise de conscience a été aussi simple que profonde : la solution n'était pas dans l'ajout de code complexe pour gérer manuellement le menu, mais au contraire, dans la simplification extrême. Il fallait arrêter de se battre contre le framework et trouver le moyen le plus simple de lui communiquer notre intention.

Notre objectif n'était plus de forcer le menu à se réduire, mais de dynamiquement **retirer la classe `.navbar-expand-lg`** au bon moment, et de laisser Bootstrap faire 99% du travail.

Dans le dernier article de cette série, nous découvrirons le code final, d'une simplicité déconcertante, qui a résolu tous les problèmes de manière stable et robuste, et nous tirerons les leçons techniques, UX et méthodologiques de cette aventure.

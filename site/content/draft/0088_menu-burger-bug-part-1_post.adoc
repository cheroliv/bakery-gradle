= Le Point de Rupture : Anatomie d'un Bug Responsive
:jbake-type: post
:jbake-status: draft
:jbake-tags: developpement, web, bootstrap, javascript, ux, ui, responsive, scrumban, gemini
:jbake-title: Le Point de Rupture : Anatomie d'un Bug Responsive
:jbake-date: 2025-09-06
:source-highlighter: pygments
:icons: font

Cette publication est la première d'une série de trois articles qui dissèquent la résolution d'un problème de menu de navigation responsive. Ce premier volet pose le décor : la quête d'une expérience utilisateur parfaite, le bug initial, et la première solution technique, une fausse bonne idée qui nous a entraînés bien plus loin que prévu.

---

== La Quête du Pixel Perfect

En tant que développeurs, nous connaissons tous cette obsession du détail. Ce petit décalage d'un pixel, cette transition qui manque de fluidité... Ces détails transforment une interface quasi parfaite en une source de frustration. Dans le cadre de la modernisation de mon site personnel et de sa migration vers Bootstrap 5, l'objectif était clair : atteindre un niveau de finition digne d'un projet professionnel pour offrir une expérience utilisateur (UX) irréprochable. C'est dans cette quête du "pixel perfect" que j'ai rencontré mon premier véritable adversaire : le menu de navigation responsive.

== Le Besoin Initial : Une Navigation Fluide et Esthétique (US-40)

Pour cadrer le besoin et ne pas perdre de vue l'objectif final, tout part d'une User Story claire, issue de notre backlog (`GEMINI.md`) :

> *US-40 : En tant que visiteur, je veux que le menu de navigation passe en mode "burger" *immédiatement* dès qu'un de ses éléments, comme "À propos", n'a plus assez de place et passe sur deux lignes, afin de garantir que le menu reste toujours sur une seule ligne, lisible et esthétique.*

L'enjeu dépasse la simple coquetterie visuelle. Un lien de menu qui passe à la ligne de manière inattendue provoque un "layout shift" : la hauteur de la barre de navigation double subitement, poussant tout le contenu de la page vers le bas. Ce phénomène, en plus d'être disgracieux, dégrade la perception de qualité et de professionnalisme du site. La transition vers le menu burger se doit d'être une transformation propre et contrôlée.

== Le Premier Symptôme : Le Passage à la Ligne Indésirable

Le problème était simple à reproduire. En redimensionnant la fenêtre du navigateur, juste avant que le point de rupture standard de Bootstrap (`lg`) ne soit atteint, le dernier élément du menu n'avait plus assez de place et passait sur deux lignes.

.Le bug initial : le passage à la ligne du menu avant le breakpoint Bootstrap.
image::/img/debug.png[Le bug initial]

Le comportement attendu était que le menu se transforme en icône "burger" *avant* que cette rupture visuelle ne se produise, garantissant une transition sans heurt.

== L'Approche Naïve : "On va le Gérer en JavaScript !"

Le premier réflexe, très commun chez les développeurs, fut de vouloir reprendre le contrôle sur le framework. Si le point de rupture de Bootstrap est fixe et ne s'adapte pas à la longueur de *mes* liens de menu, alors créons notre propre logique de détection.

La stratégie semblait astucieuse :
1.  Utiliser un `ResizeObserver` pour surveiller les changements de taille de la barre de navigation de manière performante.
2.  À chaque changement, mesurer la hauteur de chaque lien (`<li>`) du menu.
3.  Si un des éléments devient plus haut que les autres, cela signifie qu'il est passé sur deux lignes.
4.  Dans ce cas, forcer l'affichage du menu burger via JavaScript.

Voici un diagramme qui illustre cette logique :

[plantuml, format=svg, id=diag-logic-1, width=600px]
....
@startuml
title Logique de la solution initiale (et naïve)

start
:Le navigateur redimensionne la fenêtre;
:Le ResizeObserver est déclenché;
:Boucler sur chaque élément du menu;
if (La hauteur de l'élément (offsetHeight) > hauteur de référence ?) then (oui)
  :Un passage à la ligne est détecté;
  :Forcer l'affichage du menu burger via JS;
  stop
else (non)
endif
:Continuer la boucle;
:Aucun passage à la ligne;
:Assurer l'affichage normal du menu;
stop

@enduml
....

Et voici à quoi ressemblait le code JavaScript implémentant cette idée. Notez l'utilisation de `offsetHeight` pour détecter le passage à la ligne, une approche très directe qui mesure le rendu visuel de l'élément.

[source,javascript]
----
class DynamicNavbarBreakpoint {
    constructor(navbar) {
        this.navbar = navbar;
        // On cible les éléments <li> pour une mesure plus stable
        this.navItems = Array.from(navbar.querySelectorAll('.navbar-nav > .nav-item'));
        if (this.navItems.length === 0) return;

        // On stocke la hauteur de base du premier élément
        this.baseHeight = this.navItems[0].offsetHeight;

        // Utilisation d'un ResizeObserver pour la performance
        const resizeObserver = new ResizeObserver(() => this.checkBreakpoint());
        resizeObserver.observe(this.navbar);
    }

    checkBreakpoint() {
        let isWrapping = false;
        for (const item of this.navItems) {
            // Si un élément est plus haut que la normale (avec une marge), il est passé à la ligne
            if (item.offsetHeight > this.baseHeight * 1.5) {
                isWrapping = true;
                break;
            }
        }

        // C'est ici que la magie (noire) opère : on manipule directement les classes de Bootstrap
        if (isWrapping) {
            this.navbar.classList.remove('navbar-expand-lg');
        } else {
            this.navbar.classList.add('navbar-expand-lg');
        }
    }
}

// Initialisation après le chargement du DOM
document.addEventListener('DOMContentLoaded', () => {
    const navbar = document.querySelector('nav.navbar');
    if (navbar) {
        new DynamicNavbarBreakpoint(navbar);
    }
});
----

Cette approche semblait robuste. Elle était ciblée, performante et résolvait le problème de manière chirurgicale.

== Conclusion : Une Victoire de Courte Durée

Et sur le moment, ce fut un succès. Le redimensionnement était fluide, le menu burger apparaissait exactement au bon moment. J'avais l'impression d'avoir amélioré Bootstrap, d'avoir plié le framework à ma volonté pour servir un objectif UX légitime.

Mais ce que j'ignorais, c'est qu'en entrant en conflit avec les mécanismes internes de Bootstrap, je venais de créer une bombe à retardement. Cette solution, en apparence élégante, était en réalité un "patch" fragile qui allait provoquer une cascade de régressions bien plus complexes à diagnostiquer.

Le bug semblait corrigé, mais le vrai cauchemar ne faisait que commencer. Dans le prochain article, nous verrons comment ce remède s'est avéré pire que le mal, nous plongeant dans l'enfer du tâtonnement.
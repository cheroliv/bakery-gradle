= Migration de FreeMarker vers Thymeleaf : Guide pratique pour les expressions de date
:author: Votre Nom
:email: votre.email@example.com
:date: 2025-08-29
:revised: 2025-08-29
:type: post
:tags: thymeleaf, freemarker, migration, template, java
:status: published
:jbake-type: post
:jbake-status: published
:jbake-tags: thymeleaf,freemarker,migration,template,java
:jbake-date: 2025-08-29
:summary: Guide complet pour migrer vos expressions de date de FreeMarker vers Thymeleaf avec exemples pratiques et diagrammes explicatifs.
:toc: auto
:source-highlighter: highlight.js

== Introduction

La migration d'un moteur de template vers un autre est une étape cruciale dans l'évolution d'une application web. Aujourd'hui, nous allons explorer comment convertir les expressions de date de *FreeMarker* vers *Thymeleaf*, deux moteurs de template populaires dans l'écosystème Java.

Cette migration devient nécessaire lorsque vous passez d'une architecture basée sur Spring MVC avec FreeMarker vers Spring Boot avec Thymeleaf, ou simplement quand vous souhaitez moderniser votre stack technologique.

== Contexte et problématique

=== Cas d'usage typique

Imaginons une application web classique affichant un copyright avec l'année courante :

[plantuml]
----
@startuml
actor Utilisateur
participant "Page Web" as Page
participant "Moteur Template" as Template
participant "Serveur" as Server

Utilisateur -> Page : Visite la page
Page -> Template : Demande rendu footer
Template -> Server : Récupère date actuelle
Server --> Template : Retourne date
Template --> Page : Génère "© 2018-2025"
Page --> Utilisateur : Affiche footer
@enduml
----

=== Architecture avant/après migration

[plantuml]
----
@startuml
!define RECTANGLE class

package "Architecture FreeMarker" {
  RECTANGLE Controller_FM {
    +processRequest()
    +prepareModel()
  }
  RECTANGLE FreeMarker_Engine {
    +processTemplate()
    +evaluateExpression()
  }
  RECTANGLE Template_FM {
    ${.now?string("yyyy")}
  }
}

package "Architecture Thymeleaf" {
  RECTANGLE Controller_TH {
    +processRequest()
    +prepareModel()
  }
  RECTANGLE Thymeleaf_Engine {
    +processTemplate()
    +evaluateExpression()
  }
  RECTANGLE Template_TH {
    th:text="${#dates.year(#dates.createNow())}"
  }
}

Controller_FM --> FreeMarker_Engine
FreeMarker_Engine --> Template_FM

Controller_TH --> Thymeleaf_Engine
Thymeleaf_Engine --> Template_TH
@enduml
----

== Comparaison des syntaxes

=== Expression FreeMarker originale

[source,html]
----
&copy; 2018-${.now?string("yyyy")}
----

Cette expression FreeMarker utilise :

* `${...}` : délimiteurs d'expression
* `.now` : variable globale représentant la date/heure actuelle
* `?string("yyyy")` : fonction de formatage pour extraire l'année

=== Conversion vers Thymeleaf

==== Option 1 : Attribut th:text

[source,html]
----
&copy; 2018-<span th:text="${#dates.year(#dates.createNow())}"></span>
----

==== Option 2 : Expression inline

[source,html]
----
&copy; 2018-[[${#dates.year(#dates.createNow())}]]
----

=== Analyse comparative

[cols="1,2,2", options="header"]
|===
|Critère |FreeMarker |Thymeleaf

|Syntaxe
|`${.now?string("yyyy")}`
|`${#dates.year(#dates.createNow())}`

|Lisibilité
|Concise mais cryptique
|Plus verbeux mais explicite

|Fonctions utilitaires
|Méthodes sur objets
|Objets utilitaires (#dates, #strings, etc.)

|Validation HTML
|Peut casser la validation
|Préserve la structure HTML valide
|===

== Diagramme des états de migration

[plantuml]
----
@startuml
[*] --> Analyse_Code
Analyse_Code --> Inventaire_Templates : Identifier expressions FreeMarker
Inventaire_Templates --> Conversion_Syntaxe : Mapper vers équivalents Thymeleaf
Conversion_Syntaxe --> Tests_Unitaires : Vérifier fonctionnement
Tests_Unitaires --> Tests_Integration : Validation bout-en-bout
Tests_Integration --> Deploiement : Migration réussie
Tests_Integration --> Correction_Bugs : Problèmes détectés
Correction_Bugs --> Tests_Unitaires : Corrections appliquées
Deploiement --> [*]

state Conversion_Syntaxe {
  [*] --> Expressions_Date
  [*] --> Expressions_String
  [*] --> Expressions_Conditionnelles
  Expressions_Date --> Validation_Syntaxe
  Expressions_String --> Validation_Syntaxe
  Expressions_Conditionnelles --> Validation_Syntaxe
  Validation_Syntaxe --> [*]
}
@enduml
----

== Guide de migration étape par étape

=== Étape 1 : Analyse des dépendances

Avant de commencer la migration, identifiez tous les usages de FreeMarker dans votre projet :

[source,bash]
----
# Rechercher les fichiers templates FreeMarker
find . -name "*.ftl" -type f

# Rechercher les expressions FreeMarker dans les templates
grep -r "\${" --include="*.ftl" .
----

=== Étape 2 : Configuration Thymeleaf

==== Dépendance Maven

[source,xml]
----
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>
----

==== Configuration Spring Boot

[source,properties]
----
# application.properties
spring.thymeleaf.prefix=classpath:/templates/
spring.thymeleaf.suffix=.html
spring.thymeleaf.cache=false
----

=== Étape 3 : Conversion des expressions de date

==== Tableau de correspondance

[cols="2,3,2", options="header"]
|===
|FreeMarker |Thymeleaf |Description

|`${.now?string("yyyy")}`
|`${#dates.year(#dates.createNow())}`
|Année courante

|`${.now?string("MM")}`
|`${#dates.month(#dates.createNow())}`
|Mois courant

|`${.now?string("dd/MM/yyyy")}`
|`${#dates.format(#dates.createNow(), 'dd/MM/yyyy')}`
|Format de date complet

|`${date?string("yyyy")}`
|`${#dates.year(date)}`
|Année d'une date variable
|===

=== Étape 4 : Exemples d'implémentation

==== Template original (FreeMarker)

[source,html]
----
<!-- footer.ftl -->
<footer class="site-footer">
    <div class="container">
        <p>&copy; 2018-${.now?string("yyyy")} MonSite. Tous droits réservés.</p>
        <p>Dernière mise à jour : ${.now?string("dd/MM/yyyy HH:mm")}</p>
    </div>
</footer>
----

==== Template migré (Thymeleaf)

[source,html]
----
<!-- footer.html -->
<footer class="site-footer">
    <div class="container">
        <p>&copy; 2018-<span th:text="${#dates.year(#dates.createNow())}"></span> MonSite. Tous droits réservés.</p>
        <p>Dernière mise à jour : <span th:text="${#dates.format(#dates.createNow(), 'dd/MM/yyyy HH:mm')}"></span></p>
    </div>
</footer>
----

== Diagramme de flux de traitement

[plantuml]
----
if (Type d'expression ?) then (date)
  :Utilise #dates utility;
  :Appelle méthode appropriée;
elseif (string) then
  :Utilise #strings utility;
else (autres)
  :Utilise utility correspondant;
endif
----

== Bonnes pratiques et astuces

=== 1. Gestion des erreurs

[source,html]
----
<!-- Avec gestion d'erreur -->
<span th:text="${#dates.year(#dates.createNow()) ?: 'N/A'}"></span>

<!-- Avec valeur par défaut -->
<span th:text="${#dates.year(date) ?: 2025}"></span>
----

=== 2. Performances et mise en cache

Les expressions Thymeleaf sont évaluées à chaque rendu. Pour les valeurs statiques comme l'année courante, considérez :

[source,java]
----
@Controller
public class BaseController {

    @ModelAttribute("currentYear")
    public int getCurrentYear() {
        return LocalDate.now().getYear();
    }
}
----

[source,html]
----
<!-- Template optimisé -->
&copy; 2018-<span th:text="${currentYear}"></span>
----

=== 3. Tests unitaires

[source,java]
----
@ExtendWith(MockitoExtension.class)
class TemplateTest {

    @Test
    void shouldDisplayCurrentYear() {
        // Given
        Context context = new Context();

        // When
        String result = templateEngine.process("footer", context);

        // Then
        assertThat(result).contains("© 2018-" + LocalDate.now().getYear());
    }
}
----

== Diagramme de déploiement

[plantuml]
----
@startuml
node "Serveur de Production" {
 package "Application Spring Boot" {
   component "Controller Layer" as Controller
   component "Service Layer" as Service
   component "Thymeleaf Engine" as Engine
 }

 package "Templates" {
   file "footer.html" as Footer
   file "header.html" as Header
   file "main.html" as Main
 }

 database "Cache Templates" as Cache
}

node "Navigateur Client" {
 component "HTML Généré" as HTML
}

Controller --> Service
Controller --> Engine
Engine --> Footer
Engine --> Header
Engine --> Main
Engine --> Cache : mise en cache
Engine --> HTML : rendu final

@enduml
----

== Outils et ressources pour la migration

=== Script de migration automatique

[source,bash]
----
#!/bin/bash
# migration-helper.sh

# Conversion basique des expressions de date
sed -i 's/\${\.now?string("yyyy")}/${#dates.year(#dates.createNow())}/g' *.html

# Conversion des formats de date complets
sed -i 's/\${\.now?string("\([^"]*\)")}/${#dates.format(#dates.createNow(), '\''\1'\'')}/g' *.html

echo "Migration terminée. Vérifiez manuellement les résultats."
----

=== Checklist de migration

- [ ] Inventaire des templates FreeMarker
- [ ] Identification des expressions à migrer
- [ ] Configuration Thymeleaf dans Spring Boot
- [ ] Conversion des expressions de date
- [ ] Tests unitaires et d'intégration
- [ ] Validation du rendu final
- [ ] Déploiement et monitoring

== Diagramme de composants

[plantuml]
----
@startuml
package "Application Web" {
  [Controller] as CTL
  [Service] as SVC
  [Thymeleaf Engine] as TH
  [Template Cache] as CACHE
}

package "Templates Thymeleaf" {
  [footer.html] as FOOTER
  [header.html] as HEADER
  [layout.html] as LAYOUT
}

package "Utilitaires Thymeleaf" {
  [#dates] as DATES
  [#strings] as STRINGS
  [#numbers] as NUMBERS
}

CTL --> SVC : délègue logique métier
CTL --> TH : demande rendu template
TH --> FOOTER : traite template
TH --> HEADER : traite template
TH --> LAYOUT : traite template
TH --> CACHE : mise en cache
TH --> DATES : expressions de date
TH --> STRINGS : expressions de chaînes
TH --> NUMBERS : expressions numériques

note right of TH : Engine Thymeleaf\nremplace FreeMarker
note bottom of DATES : Remplace .now?string()
@enduml
----

== Avantages de la migration

=== Comparaison technique

[cols="1,2,2", options="header"]
|===
|Aspect |FreeMarker |Thymeleaf

|**Intégration Spring**
|Configuration manuelle requise
|Intégration native Spring Boot

|**Validation HTML**
|Templates non-HTML valides
|Templates HTML5 valides

|**Mode de développement**
|Rechargement manuel
|Rechargement automatique

|**Debugging**
|Messages d'erreur cryptiques
|Messages d'erreur explicites

|**Écosystème**
|Communauté réduite
|Large adoption Spring
|===

== Pièges à éviter

WARNING: Attention aux différences de comportement entre les deux moteurs !

=== 1. Gestion des valeurs nulles

[source,html]
----
<!-- FreeMarker - gestion automatique des null -->
${date?string("yyyy")}

<!-- Thymeleaf - gestion explicite nécessaire -->
<span th:text="${date != null ? #dates.year(date) : 'N/A'}"></span>
----

=== 2. Échappement des caractères

[source,html]
----
<!-- FreeMarker -->
${message?html}

<!-- Thymeleaf (échappement automatique) -->
<span th:text="${message}"></span>

<!-- Thymeleaf (sans échappement) -->
<span th:utext="${message}"></span>
----

== Conclusion

La migration de FreeMarker vers Thymeleaf, bien que nécessitant une attention particulière aux détails syntaxiques, apporte de nombreux avantages en termes de maintenabilité et d'intégration avec l'écosystème Spring.

Les expressions de date, comme notre exemple `${.now?string("yyyy")}` vers `${#dates.year(#dates.createNow())}`, illustrent parfaitement cette évolution vers une syntaxe plus explicite et robuste.

=== Points clés à retenir

* Thymeleaf privilégie la lisibilité sur la concision
* Les templates restent du HTML valide
* L'intégration Spring Boot est native
* Les outils de debugging sont plus performants

La migration représente un investissement initial qui se traduit par une meilleure expérience de développement et une maintenance simplifiée à long terme.

---

*Cet article vous a aidé ? Partagez vos retours d'expérience de migration dans les commentaires !*



== JBake, Freemarker et Thymeleaf : un choix de moteur de template dans le statique

JBake est un générateur de site statique qui prend en charge plusieurs moteurs de templates : principalement **Freemarker** (`.ftl`) et **Thymeleaf** (`.html` avec dialectes).
Lors d'une migration ou d'une personnalisation, il est essentiel de comprendre comment ces deux moteurs interagissent avec JBake.

=== Exemple avec Freemarker

Un template *Freemarker* dans JBake ressemble à ceci :

[source,ftl]
----
<#-- layouts/base.ftl -->
<!DOCTYPE html>
<html>
<head>
  <title>${title}</title>
</head>
<body>
  <h1>${content.title}</h1>
  <p>Publié le ${published_date?string("dd/MM/yyyy")}</p>
  <div>
    ${content.body}
  </div>
</body>
</html>
----

L'expression `?string("dd/MM/yyyy")` est spécifique à Freemarker pour formater une date.

=== Exemple avec Thymeleaf

Un template *Thymeleaf* équivalent pourrait être :

[source,html]
----
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
  <title th:text="\${title}">Titre par défaut</title>
</head>
<body>
  <h1 th:text="\${content.title}"></h1>
  <p>Publié le <span th:text="\${#dates.format(published_date, 'dd/MM/yyyy')}"></span></p>
  <div th:utext="\${content.body}"></div>
</body>
</html>
----

Ici, la fonction `#dates.format(...)` est fournie par le dialecte standard de Thymeleaf.

=== Configuration JBake

Pour basculer entre Freemarker et Thymeleaf dans JBake, on configure le fichier `jbake.properties` :

[source,properties]
----
# Choisir Freemarker
template.engine=freemarker

# Ou choisir Thymeleaf
# template.engine=thymeleaf
----

Cette souplesse permet de tester rapidement un moteur ou l'autre sans changer la logique de génération.

== Diagrammes UML pour illustrer la problématique

=== Cas d’usage

[plantuml, "usecase-choix-moteur", svg]
----
@startuml
actor "Développeur" as Dev
rectangle JBake {
  usecase "Configurer jbake.properties" as UC1
  usecase "Écrire template Freemarker (.ftl)" as UC2
  usecase "Écrire template Thymeleaf (.html)" as UC3
  usecase "Générer site statique" as UC4
}
Dev --> UC1
Dev --> UC2
Dev --> UC3
UC1 --> UC4
UC2 --> UC4
UC3 --> UC4
@enduml
----

=== Flow de génération JBake

[plantuml, "flow-jbake", svg]
----
@startuml
start
:Lire jbake.properties;
if (template.engine == freemarker) then (oui)
  :Charger moteur Freemarker;
  :Appliquer templates .ftl;
else (non)
  :Charger moteur Thymeleaf;
  :Appliquer templates .html;
endif
:Assembler contenu (Markdown/Asciidoc);
:Générer fichiers HTML statiques;
stop
@enduml
----

=== Diagramme de déploiement

[plantuml, "deploy-jbake", svg]
----
@startuml
node "Laptop Dev" {
  component "JBake CLI" as jbake
  component "Freemarker" as ftl
  component "Thymeleaf" as th
}

node "Serveur Web" {
  artifact "Site statique HTML"
}

jbake --> ftl
jbake --> th
jbake --> "Site statique HTML"
@enduml
----

=== Diagramme d’état du contenu

[plantuml, "state-contenu", svg]
----
@startuml
[*] --> Brouillon
Brouillon --> Rédigé : contenu écrit (adoc/md)
Rédigé --> Enrichi : métadonnées ajoutées
Enrichi --> Généré : rendu via template (ftl/html)
Généré --> Publié : déployé sur serveur web
@enduml
----

=== Diagramme de composants

[plantuml, "component-jbake", svg]
----
@startuml
package "JBake" {
  [Core] --> [Parser Asciidoc/Markdown]
  [Core] --> [Template Engine]
  [Template Engine] --> [Freemarker Adapter]
  [Template Engine] --> [Thymeleaf Adapter]
}

[Parser Asciidoc/Markdown] --> [Contenu Structuré]
[Freemarker Adapter] --> [HTML rendu FTL]
[Thymeleaf Adapter] --> [HTML rendu TH]
@enduml
----

== Conclusion enrichie

L’enjeu principal n’est pas uniquement syntaxique (les expressions de dates par exemple), mais bien **architectural** : choisir entre Freemarker et Thymeleaf dépend du degré de compatibilité recherché, de l’écosystème déjà en place, et de la capacité à maintenir des templates sur le long terme dans un site statique JBake.

= Tester votre code TypeScript dans JBake : Tests unitaires avec Vitest et tests E2E avec Playwright
@cheroliv
2025-05-28
:jbake-type: post
:jbake-status: published
:jbake-tags: jbake, typescript, vite, vitest, playwright, testing
:idprefix:
:summary: Tester votre code TypeScript dans JBake : Tests unitaires avec Vitest et tests E2E avec Playwright
:icons: font
:sectnumlevels: 6
:sectnums:
:toc: left
:toc-title: Sommaire

Intégrer TypeScript dans JBake avec Vite

Dans la link:/blog/2025/integrer-typescript-jbake-vite.html[première partie] de cette série, nous avons vu comment intégrer TypeScript dans JBake avec Vite.
Maintenant, nous allons ajouter une stratégie de test complète avec des tests unitaires via Vitest et des tests end-to-end avec Playwright.

== Pourquoi tester dans un contexte JBake ?

Même pour un site statique, les tests apportent une valeur considérable :

* **Tests unitaires** - Validez la logique métier de vos composants TypeScript
* **Tests d'intégration** - Vérifiez les interactions entre composants
* **Tests E2E** - Assurez-vous que l'expérience utilisateur fonctionne correctement
* **Régression** - Détectez automatiquement les cassures lors des modifications

== Architecture de test

Notre stratégie de test suit la pyramide classique :

[source]
----
        /\
       /  \     Tests E2E (Playwright)
      /____\    - Navigation
     /      \   - Workflows utilisateur
    /        \  - Tests cross-browser
   /__________\
  /            \ Tests d'intégration (Vitest + jsdom)
 /              \ - Interactions DOM
/________________\ - API calls mockées
|                |
|  Tests unitaires| Tests unitaires (Vitest)
|   (Vitest)     | - Logique métier
|________________| - Fonctions pures
----

== Structure du projet mise à jour

[source]
----
mon-blog/
├── src/
│   ├── main/jbake/              # JBake standard
│   └── ts/                      # Sources TypeScript
│       ├── components/
│       ├── utils/
│       └── __tests__/           # Tests unitaires
│           ├── components/
│           ├── utils/
│           └── setup.ts
├── tests/
│   ├── e2e/                     # Tests Playwright
│   │   ├── blog.spec.ts
│   │   ├── search.spec.ts
│   │   └── fixtures/
│   └── integration/             # Tests d'intégration
├── dist/                        # JavaScript compilé
├── build/                       # Site JBake généré
├── package.json
├── vite.config.js
├── vitest.config.js
├── playwright.config.js
└── tsconfig.json
----

== Configuration des tests unitaires avec Vitest

=== Installation des dépendances

[source,bash]
----
# Tests unitaires avec Vitest
npm install -D vitest jsdom @vitest/ui

# Utilitaires de test
npm install -D @testing-library/dom @testing-library/user-event
npm install -D @types/jsdom

# Mocking et assertions avancées
npm install -D msw
----

=== Configuration Vitest

Créez le fichier `vitest.config.js` :

[source,javascript]
----
import { defineConfig } from 'vitest/config'
import { resolve } from 'path'

export default defineConfig({
  test: {
    environment: 'jsdom',
    setupFiles: ['src/ts/__tests__/setup.ts'],
    globals: true,
    css: true,
    coverage: {
      provider: 'v8',
      reporter: ['text', 'html', 'lcov'],
      exclude: [
        'node_modules/',
        'dist/',
        'build/',
        'tests/',
        '**/*.config.js',
        '**/*.d.ts'
      ]
    }
  },
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src/ts')
    }
  }
})
----

=== Fichier de setup des tests

Créez `src/ts/__tests__/setup.ts` :

[source,typescript]
----
import { vi } from 'vitest'
import '@testing-library/jest-dom'

// Mock des APIs du navigateur non disponibles dans jsdom
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: vi.fn().mockImplementation(query => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: vi.fn(),
    removeListener: vi.fn(),
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
    dispatchEvent: vi.fn(),
  })),
})

// Mock fetch global
global.fetch = vi.fn()

// Mock pour localStorage
const localStorageMock = {
  getItem: vi.fn(),
  setItem: vi.fn(),
  removeItem: vi.fn(),
  clear: vi.fn(),
}
Object.defineProperty(window, 'localStorage', {
  value: localStorageMock
})

// Nettoyage entre les tests
beforeEach(() => {
  document.body.innerHTML = ''
  vi.clearAllMocks()
})
----

== Tests unitaires : Exemples pratiques

=== Test d'une classe utilitaire

Créez `src/ts/utils/SearchUtils.ts` :

[source,typescript]
----
export interface SearchResult {
  title: string;
  url: string;
  excerpt: string;
  score: number;
}

export class SearchUtils {
  static filterResults(
    results: SearchResult[],
    minScore: number = 0.5
  ): SearchResult[] {
    return results
      .filter(result => result.score >= minScore)
      .sort((a, b) => b.score - a.score);
  }

  static highlightMatches(text: string, query: string): string {
    if (!query.trim()) return text;

    const regex = new RegExp(`(${this.escapeRegex(query)})`, 'gi');
    return text.replace(regex, '<mark>$1</mark>');
  }

  static escapeRegex(string: string): string {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  static debounce<T extends (...args: any[]) => any>(
    func: T,
    delay: number
  ): (...args: Parameters<T>) => void {
    let timeoutId: ReturnType<typeof setTimeout>;

    return (...args: Parameters<T>) => {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => func(...args), delay);
    };
  }
}
----

Test correspondant `src/ts/__tests__/utils/SearchUtils.test.ts` :

[source,typescript]
----
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { SearchUtils, type SearchResult } from '@/utils/SearchUtils'

describe('SearchUtils', () => {
  const mockResults: SearchResult[] = [
    { title: 'Article 1', url: '/article-1', excerpt: 'Premier article', score: 0.8 },
    { title: 'Article 2', url: '/article-2', excerpt: 'Deuxième article', score: 0.3 },
    { title: 'Article 3', url: '/article-3', excerpt: 'Troisième article', score: 0.9 },
  ]

  describe('filterResults', () => {
    it('should filter results by minimum score', () => {
      const filtered = SearchUtils.filterResults(mockResults, 0.5)

      expect(filtered).toHaveLength(2)
      expect(filtered[0].title).toBe('Article 3') // Score le plus élevé en premier
      expect(filtered[1].title).toBe('Article 1')
    })

    it('should use default minimum score of 0.5', () => {
      const filtered = SearchUtils.filterResults(mockResults)

      expect(filtered).toHaveLength(2)
    })

    it('should return empty array when no results meet minimum score', () => {
      const filtered = SearchUtils.filterResults(mockResults, 1.0)

      expect(filtered).toHaveLength(0)
    })

    it('should sort results by score in descending order', () => {
      const filtered = SearchUtils.filterResults(mockResults, 0.1)

      expect(filtered[0].score).toBe(0.9)
      expect(filtered[1].score).toBe(0.8)
      expect(filtered[2].score).toBe(0.3)
    })
  })

  describe('highlightMatches', () => {
    it('should highlight matching text', () => {
      const result = SearchUtils.highlightMatches('TypeScript est formidable', 'TypeScript')

      expect(result).toBe('<mark>TypeScript</mark> est formidable')
    })

    it('should be case insensitive', () => {
      const result = SearchUtils.highlightMatches('TypeScript est formidable', 'typescript')

      expect(result).toBe('<mark>TypeScript</mark> est formidable')
    })

    it('should handle multiple matches', () => {
      const result = SearchUtils.highlightMatches('TypeScript et typescript', 'typescript')

      expect(result).toBe('<mark>TypeScript</mark> et <mark>typescript</mark>')
    })

    it('should handle empty query', () => {
      const text = 'TypeScript est formidable'
      const result = SearchUtils.highlightMatches(text, '')

      expect(result).toBe(text)
    })

    it('should escape regex special characters', () => {
      const result = SearchUtils.highlightMatches('Test (regex)', '(regex)')

      expect(result).toBe('Test <mark>(regex)</mark>')
    })
  })

  describe('debounce', () => {
    beforeEach(() => {
      vi.useFakeTimers()
    })

    afterEach(() => {
      vi.useRealTimers()
    })

    it('should delay function execution', () => {
      const mockFn = vi.fn()
      const debouncedFn = SearchUtils.debounce(mockFn, 100)

      debouncedFn('test')
      expect(mockFn).not.toHaveBeenCalled()

      vi.advanceTimersByTime(100)
      expect(mockFn).toHaveBeenCalledWith('test')
    })

    it('should cancel previous calls', () => {
      const mockFn = vi.fn()
      const debouncedFn = SearchUtils.debounce(mockFn, 100)

      debouncedFn('first')
      debouncedFn('second')

      vi.advanceTimersByTime(100)

      expect(mockFn).toHaveBeenCalledTimes(1)
      expect(mockFn).toHaveBeenCalledWith('second')
    })
  })
})
----

=== Test d'un composant avec DOM

Test pour la classe `BlogSearch` `src/ts/__tests__/components/BlogSearch.test.ts` :

[source,typescript]
----
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { screen, fireEvent, waitFor } from '@testing-library/dom'
import userEvent from '@testing-library/user-event'
import { BlogSearch } from '@/components/BlogSearch'

// Mock des réponses API
const mockSearchResponse = {
  items: [
    {
      title: 'Premier article',
      url: '/article-1',
      excerpt: 'Description du premier article'
    }
  ],
  total: 1
}

describe('BlogSearch', () => {
  let container: HTMLElement
  let user: ReturnType<typeof userEvent.setup>

  beforeEach(() => {
    user = userEvent.setup()

    // Setup DOM
    document.body.innerHTML = `
      <div>
        <input type="search" id="search" placeholder="Rechercher...">
        <div id="search-results" class="search-results-container"></div>
      </div>
    `

    container = document.body.firstElementChild as HTMLElement

    // Mock fetch
    global.fetch = vi.fn().mockResolvedValue({
      ok: true,
      json: () => Promise.resolve(mockSearchResponse)
    } as Response)
  })

  it('should initialize without errors', () => {
    expect(() => new BlogSearch()).not.toThrow()
  })

  it('should throw error if required elements are missing', () => {
    document.body.innerHTML = '<div></div>'

    expect(() => new BlogSearch()).toThrow('Required elements not found')
  })

  it('should perform search when input has sufficient length', async () => {
    new BlogSearch({ minLength: 2, debounceMs: 0 })

    const searchInput = screen.getByPlaceholderText('Rechercher...')

    await user.type(searchInput, 'typescript')

    await waitFor(() => {
      expect(fetch).toHaveBeenCalledWith('/search.json?q=typescript')
    })
  })

  it('should not search if input is too short', async () => {
    new BlogSearch({ minLength: 3, debounceMs: 0 })

    const searchInput = screen.getByPlaceholderText('Rechercher...')

    await user.type(searchInput, 'ts')

    expect(fetch).not.toHaveBeenCalled()
  })

  it('should display search results', async () => {
    new BlogSearch({ minLength: 2, debounceMs: 0 })

    const searchInput = screen.getByPlaceholderText('Rechercher...')

    await user.type(searchInput, 'typescript')

    await waitFor(() => {
      expect(screen.getByText('Premier article')).toBeInTheDocument()
      expect(screen.getByText('1 résultat(s)')).toBeInTheDocument()
    })
  })

  it('should handle API errors gracefully', async () => {
    global.fetch = vi.fn().mockRejectedValue(new Error('Network error'))

    // Spy sur console.error pour vérifier le logging
    const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {})

    new BlogSearch({ minLength: 2, debounceMs: 0 })

    const searchInput = screen.getByPlaceholderText('Rechercher...')

    await user.type(searchInput, 'typescript')

    await waitFor(() => {
      expect(screen.getByText('Erreur lors de la recherche')).toBeInTheDocument()
      expect(consoleSpy).toHaveBeenCalledWith('Search failed:', expect.any(Error))
    })

    consoleSpy.mockRestore()
  })

  it('should clear results when pressing Escape', async () => {
    new BlogSearch({ minLength: 2, debounceMs: 0 })

    const searchInput = screen.getByPlaceholderText('Rechercher...')

    // Effectuer une recherche d'abord
    await user.type(searchInput, 'typescript')

    await waitFor(() => {
      expect(screen.getByText('Premier article')).toBeInTheDocument()
    })

    // Appuyer sur Escape
    await user.keyboard('{Escape}')

    const resultsContainer = document.getElementById('search-results')!
    expect(resultsContainer.innerHTML).toBe('')
    expect(resultsContainer.classList.contains('visible')).toBe(false)
  })

  it('should escape HTML in results', async () => {
    const maliciousResponse = {
      items: [{
        title: '<script>alert("xss")</script>',
        url: '/safe-url',
        excerpt: 'Safe excerpt'
      }],
      total: 1
    }

    global.fetch = vi.fn().mockResolvedValue({
      ok: true,
      json: () => Promise.resolve(maliciousResponse)
    } as Response)

    new BlogSearch({ minLength: 2, debounceMs: 0 })

    const searchInput = screen.getByPlaceholderText('Rechercher...')

    await user.type(searchInput, 'test')

    await waitFor(() => {
      // Vérifier que le script n'est pas exécuté
      expect(document.body.innerHTML).toContain('&lt;script&gt;')
      expect(document.body.innerHTML).not.toContain('<script>')
    })
  })
})
----

== Configuration des tests E2E avec Playwright

=== Installation de Playwright

[source,bash]
----
npm install -D @playwright/test
npx playwright install
----

=== Configuration Playwright

Créez `playwright.config.js` :

[source,javascript]
----
import { defineConfig, devices } from '@playwright/test'

export default defineConfig({
  testDir: './tests/e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: [
    ['html'],
    ['json', { outputFile: 'test-results/results.json' }]
  ],
  use: {
    baseURL: 'http://localhost:8820',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
  },

  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
    {
      name: 'Mobile Chrome',
      use: { ...devices['Pixel 5'] },
    },
    {
      name: 'Mobile Safari',
      use: { ...devices['iPhone 12'] },
    },
  ],

  webServer: [
    {
      command: 'npm run build && npx jbake -s',
      port: 8820,
      reuseExistingServer: !process.env.CI,
    }
  ],
})
----

=== Tests E2E : Navigation et recherche

Créez `tests/e2e/blog.spec.ts` :

[source,typescript]
----
import { test, expect } from '@playwright/test'

test.describe('Blog Navigation', () => {
  test('should load homepage', async ({ page }) => {
    await page.goto('/')

    await expect(page).toHaveTitle(/Mon Blog/)
    await expect(page.locator('h1')).toBeVisible()
  })

  test('should navigate to blog posts', async ({ page }) => {
    await page.goto('/')

    // Cliquer sur un lien d'article
    await page.click('a[href*="/blog/"]')

    // Vérifier que nous sommes sur une page d'article
    await expect(page.locator('article')).toBeVisible()
    await expect(page.locator('.post-content')).toBeVisible()
  })

  test('should have working RSS feed', async ({ page }) => {
    const response = await page.goto('/feed.xml')

    expect(response?.status()).toBe(200)
    expect(response?.headers()['content-type']).toContain('xml')
  })
})

test.describe('Responsive Design', () => {
  test('should be mobile friendly', async ({ page }) => {
    await page.setViewportSize({ width: 375, height: 667 })
    await page.goto('/')

    // Vérifier que le menu mobile fonctionne
    const menuButton = page.locator('[data-testid="mobile-menu"]')
    if (await menuButton.isVisible()) {
      await menuButton.click()
      await expect(page.locator('.mobile-menu')).toBeVisible()
    }
  })

  test('should adapt layout on tablet', async ({ page }) => {
    await page.setViewportSize({ width: 768, height: 1024 })
    await page.goto('/')

    await expect(page.locator('.container')).toHaveCSS('max-width', '768px')
  })
})
----

Créez `tests/e2e/search.spec.ts` :

[source,typescript]
----
import { test, expect } from '@playwright/test'

test.describe('Search Functionality', () => {
  test.beforeEach(async ({ page }) => {
    // Mocker l'API de recherche
    await page.route('/search.json*', async route => {
      const url = route.request().url()
      const query = new URL(url).searchParams.get('q')

      const mockResponse = {
        items: query ? [
          {
            title: `Résultat pour "${query}"`,
            url: '/blog/test-article',
            excerpt: `Ceci est un extrait contenant ${query}`
          }
        ] : [],
        total: query ? 1 : 0
      }

      await route.fulfill({
        status: 200,
        contentType: 'application/json',
        body: JSON.stringify(mockResponse)
      })
    })

    await page.goto('/')
  })

  test('should show search results', async ({ page }) => {
    const searchInput = page.locator('#search')
    const resultsContainer = page.locator('#search-results')

    await searchInput.fill('typescript')

    // Attendre que les résultats apparaissent
    await expect(resultsContainer).toBeVisible()
    await expect(page.locator('.search-result')).toHaveCount(1)
    await expect(page.getByText('Résultat pour "typescript"')).toBeVisible()
  })

  test('should handle empty search results', async ({ page }) => {
    await page.route('/search.json*', async route => {
      await route.fulfill({
        status: 200,
        contentType: 'application/json',
        body: JSON.stringify({ items: [], total: 0 })
      })
    })

    const searchInput = page.locator('#search')

    await searchInput.fill('nonexistent')

    await expect(page.getByText('Aucun résultat trouvé')).toBeVisible()
  })

  test('should close search results with Escape', async ({ page }) => {
    const searchInput = page.locator('#search')
    const resultsContainer = page.locator('#search-results')

    // Effectuer une recherche
    await searchInput.fill('typescript')
    await expect(resultsContainer).toBeVisible()

    // Appuyer sur Escape
    await page.keyboard.press('Escape')

    await expect(resultsContainer).not.toHaveClass(/visible/)
  })

  test('should handle search API errors', async ({ page }) => {
    await page.route('/search.json*', async route => {
      await route.fulfill({
        status: 500,
        contentType: 'application/json',
        body: JSON.stringify({ error: 'Internal Server Error' })
      })
    })

    // Spy sur les erreurs console
    const consoleErrors: string[] = []
    page.on('console', msg => {
      if (msg.type() === 'error') {
        consoleErrors.push(msg.text())
      }
    })

    const searchInput = page.locator('#search')

    await searchInput.fill('error')

    await expect(page.getByText('Erreur lors de la recherche')).toBeVisible()

    // Vérifier qu'une erreur a été loggée
    await page.waitForTimeout(100)
    expect(consoleErrors.some(error => error.includes('Search failed'))).toBe(true)
  })

  test('should debounce search requests', async ({ page }) => {
    let requestCount = 0

    await page.route('/search.json*', async route => {
      requestCount++
      await route.fulfill({
        status: 200,
        contentType: 'application/json',
        body: JSON.stringify({ items: [], total: 0 })
      })
    })

    const searchInput = page.locator('#search')

    // Taper rapidement plusieurs caractères
    await searchInput.pressSequentially('typescript', { delay: 50 })

    // Attendre que le debounce se termine
    await page.waitForTimeout(500)

    // Vérifier qu'une seule requête a été envoyée
    expect(requestCount).toBe(1)
  })
})

test.describe('Search Accessibility', () => {
  test('should be keyboard navigable', async ({ page }) => {
    await page.goto('/')

    // Naviguer au champ de recherche avec Tab
    await page.keyboard.press('Tab')
    await expect(page.locator('#search')).toBeFocused()

    // Effectuer une recherche
    await page.keyboard.type('typescript')

    // Vérifier que les résultats sont accessibles au clavier
    await page.keyboard.press('Tab')
    await expect(page.locator('.search-result a').first()).toBeFocused()
  })

  test('should have proper ARIA attributes', async ({ page }) => {
    await page.goto('/')

    const searchInput = page.locator('#search')
    const resultsContainer = page.locator('#search-results')

    // Vérifier les attributs ARIA
    await expect(searchInput).toHaveAttribute('role', 'searchbox')
    await expect(resultsContainer).toHaveAttribute('role', 'region')
    await expect(resultsContainer).toHaveAttribute('aria-live', 'polite')
  })
})
----

== Scripts de test intégrés

Mettez à jour votre `package.json` :

[source,json]
----
{
  "scripts": {
    "dev:ts": "vite",
    "build:ts": "vite build",
    "dev": "concurrently \"npm run dev:ts\" \"./gradlew jbakeServe\"",
    "build": "npm run build:ts && ./gradlew jbake",

    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage",
    "test:watch": "vitest --watch",

    "test:e2e": "playwright test",
    "test:e2e:ui": "playwright test --ui",
    "test:e2e:headed": "playwright test --headed",
    "test:e2e:debug": "playwright test --debug",

    "test:all": "npm run test:coverage && npm run test:e2e",
    "test:ci": "npm run build && npm run test:coverage && npm run test:e2e"
  }
}
----

== Intégration avec le build Gradle

Mettez à jour votre `build.gradle` :

[source,groovy]
----
plugins {
    id 'org.jbake.site' version '5.3.0'
    id 'com.github.node-gradle.node' version '3.5.1'
}

// Tasks de test
task testUnit(type: NpmTask) {
    args = ['run', 'test:coverage']
    inputs.dir('src/ts')
    outputs.dir('coverage')
}

task testE2E(type: NpmTask) {
    args = ['run', 'test:e2e']
    inputs.dir('tests/e2e')
    inputs.dir('build') // Dépend du site généré
    outputs.dir('test-results')
    dependsOn jbake
}

task testAll(type: NpmTask) {
    args = ['run', 'test:all']
    dependsOn buildTypeScript
}

// Configuration des dépendances
buildTypeScript.dependsOn npmInstall
testUnit.dependsOn buildTypeScript
jbake.dependsOn testUnit  // Les tests doivent passer avant le build

// Task pour le pipeline CI/CD
task ciPipeline {
    dependsOn testAll
    description = 'Pipeline complet : build, tests unitaires et E2E'
}
----

== Intégration CI/CD

=== GitHub Actions

Créez `.github/workflows/test.yml` :

[source,yaml]
----
name: Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [18, 20]

    steps:
    - uses: actions/checkout@v4

    - name: Setup Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'

    - name: Setup Java
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'

    - name: Install dependencies
      run: npm ci

    - name: Run unit tests
      run: npm run test:coverage

    - name: Build site
      run: ./gradlew jbake

    - name: Install Playwright browsers
      run: npx playwright install --with-deps

    - name: Run E2E tests
      run: npm run test:e2e

    - name: Upload coverage reports
      uses: codecov/codecov-action@v4
      with:
        file: ./coverage/lcov.info

    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: playwright-report-${{ matrix.node-version }}
        path: playwright-report/
        retention-days: 30
----

== Bonnes pratiques de test

=== Tests unitaires

* **Testez la logique métier** - Pas les détails d'implémentation
* **Un test = un comportement** - Tests focalisés et lisibles
* **Arrange, Act, Assert** - Structure claire des tests
* **Mockez les dépendances externes** - Tests isolés et rapides

=== Tests d'intégration

* **Testez les interactions** - Entre composants et avec le DOM
* **Simulez les conditions réelles** - Événements utilisateur authentiques
* **Vérifiez les effets de bord** - État global, stockage local, etc.

=== Tests E2E

* **Testez les parcours critiques** - Workflows métier importants
* **Tests stables** - Utilisez des sélecteurs robustes
* **Données de test isolées** - Évitez les dépendances entre tests
* **Performance** - Limitez le nombre de tests E2E

=== Organisation des tests

// [source,typescript]
// ----
==== Tester votre code TypeScript dans JBake : Tests unitaires avec Vitest et tests E2E avec Playwright

Dans la link:/blog/2025/integrer-typescript-jbake-vite.html[première partie] de cette série, nous avons vu comment intégrer TypeScript dans JBake avec Vite.
Maintenant, nous allons ajouter une stratégie de test complète avec des tests unitaires via Vitest et des tests end-to-end avec Playwright.

===== Pourquoi tester dans un contexte JBake ?

Même pour un site statique, les tests apportent une valeur considérable :

* **Tests unitaires** - Validez la logique métier de vos composants TypeScript
* **Tests d'intégration** - Vérifiez les interactions entre composants
* **Tests E2E** - Assurez-vous que l'expérience utilisateur fonctionne correctement
* **Régression** - Détectez automatiquement les cassures lors des modifications

==== Architecture de test

Notre stratégie de test suit la pyramide classique :

[source]
----
        /\
       /  \     Tests E2E (Playwright)
      /____\    - Navigation
     /      \   - Workflows utilisateur
    /        \  - Tests cross-browser
   /__________\
  /            \ Tests d'intégration (Vitest + jsdom)
 /              \ - Interactions DOM
/________________\ - API calls mockées
|                |
|  Tests unitaires| Tests unitaires (Vitest)
|   (Vitest)     | - Logique métier
|________________| - Fonctions pures
----

==== Structure du projet mise à jour

[source]
----
mon-blog/
├── src/
│   ├── main/jbake/              # JBake standard
│   └── ts/                      # Sources TypeScript
│       ├── components/
│       ├── utils/
│       └── __tests__/           # Tests unitaires
│           ├── components/
│           ├── utils/
│           └── setup.ts
├── tests/
│   ├── e2e/                     # Tests Playwright
│   │   ├── blog.spec.ts
│   │   ├── search.spec.ts
│   │   └── fixtures/
│   └── integration/             # Tests d'intégration
├── dist/                        # JavaScript compilé
├── build/                       # Site JBake généré
├── package.json
├── vite.config.js
├── vitest.config.js
├── playwright.config.js
└── tsconfig.json
----

== Configuration des tests unitaires avec Vitest

=== Installation des dépendances

[source,bash]
----
# Tests unitaires avec Vitest
npm install -D vitest jsdom @vitest/ui

# Utilitaires de test
npm install -D @testing-library/dom @testing-library/user-event
npm install -D @types/jsdom

# Mocking et assertions avancées
npm install -D msw
----

=== Configuration Vitest

Créez le fichier `vitest.config.js` :

[source,javascript]
----
import { defineConfig } from 'vitest/config'
import { resolve } from 'path'

export default defineConfig({
  test: {
    environment: 'jsdom',
    setupFiles: ['src/ts/__tests__/setup.ts'],
    globals: true,
    css: true,
    coverage: {
      provider: 'v8',
      reporter: ['text', 'html', 'lcov'],
      exclude: [
        'node_modules/',
        'dist/',
        'build/',
        'tests/',
        '**/*.config.js',
        '**/*.d.ts'
      ]
    }
  },
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src/ts')
    }
  }
})
----

=== Fichier de setup des tests

Créez `src/ts/__tests__/setup.ts` :

[source,typescript]
----
import { vi } from 'vitest'
import '@testing-library/jest-dom'

// Mock des APIs du navigateur non disponibles dans jsdom
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: vi.fn().mockImplementation(query => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: vi.fn(),
    removeListener: vi.fn(),
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
    dispatchEvent: vi.fn(),
  })),
})

// Mock fetch global
global.fetch = vi.fn()

// Mock pour localStorage
const localStorageMock = {
  getItem: vi.fn(),
  setItem: vi.fn(),
  removeItem: vi.fn(),
  clear: vi.fn(),
}
Object.defineProperty(window, 'localStorage', {
  value: localStorageMock
})

// Nettoyage entre les tests
beforeEach(() => {
  document.body.innerHTML = ''
  vi.clearAllMocks()
})
----

== Tests unitaires : Exemples pratiques

=== Test d'une classe utilitaire

Créez `src/ts/utils/SearchUtils.ts` :

[source,typescript]
----
export interface SearchResult {
  title: string;
  url: string;
  excerpt: string;
  score: number;
}

export class SearchUtils {
  static filterResults(
    results: SearchResult[],
    minScore: number = 0.5
  ): SearchResult[] {
    return results
      .filter(result => result.score >= minScore)
      .sort((a, b) => b.score - a.score);
  }

  static highlightMatches(text: string, query: string): string {
    if (!query.trim()) return text;

    const regex = new RegExp(`(${this.escapeRegex(query)})`, 'gi');
    return text.replace(regex, '<mark>$1</mark>');
  }

  static escapeRegex(string: string): string {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  static debounce<T extends (...args: any[]) => any>(
    func: T,
    delay: number
  ): (...args: Parameters<T>) => void {
    let timeoutId: ReturnType<typeof setTimeout>;

    return (...args: Parameters<T>) => {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => func(...args), delay);
    };
  }
}
----

Test correspondant `src/ts/__tests__/utils/SearchUtils.test.ts` :

[source,typescript]
----
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { SearchUtils, type SearchResult } from '@/utils/SearchUtils'

describe('SearchUtils', () => {
  const mockResults: SearchResult[] = [
    { title: 'Article 1', url: '/article-1', excerpt: 'Premier article', score: 0.8 },
    { title: 'Article 2', url: '/article-2', excerpt: 'Deuxième article', score: 0.3 },
    { title: 'Article 3', url: '/article-3', excerpt: 'Troisième article', score: 0.9 },
  ]

  describe('filterResults', () => {
    it('should filter results by minimum score', () => {
      const filtered = SearchUtils.filterResults(mockResults, 0.5)

      expect(filtered).toHaveLength(2)
      expect(filtered[0].title).toBe('Article 3') // Score le plus élevé en premier
      expect(filtered[1].title).toBe('Article 1')
    })

    it('should use default minimum score of 0.5', () => {
      const filtered = SearchUtils.filterResults(mockResults)

      expect(filtered).toHaveLength(2)
    })

    it('should return empty array when no results meet minimum score', () => {
      const filtered = SearchUtils.filterResults(mockResults, 1.0)

      expect(filtered).toHaveLength(0)
    })

    it('should sort results by score in descending order', () => {
      const filtered = SearchUtils.filterResults(mockResults, 0.1)

      expect(filtered[0].score).toBe(0.9)
      expect(filtered[1].score).toBe(0.8)
      expect(filtered[2].score).toBe(0.3)
    })
  })

  describe('highlightMatches', () => {
    it('should highlight matching text', () => {
      const result = SearchUtils.highlightMatches('TypeScript est formidable', 'TypeScript')

      expect(result).toBe('<mark>TypeScript</mark> est formidable')
    })

    it('should be case insensitive', () => {
      const result = SearchUtils.highlightMatches('TypeScript est formidable', 'typescript')

      expect(result).toBe('<mark>TypeScript</mark> est formidable')
    })

    it('should handle multiple matches', () => {
      const result = SearchUtils.highlightMatches('TypeScript et typescript', 'typescript')

      expect(result).toBe('<mark>TypeScript</mark> et <mark>typescript</mark>')
    })

    it('should handle empty query', () => {
      const text = 'TypeScript est formidable'
      const result = SearchUtils.highlightMatches(text, '')

      expect(result).toBe(text)
    })

    it('should escape regex special characters', () => {
      const result = SearchUtils.highlightMatches('Test (regex)', '(regex)')

      expect(result).toBe('Test <mark>(regex)</mark>')
    })
  })

  describe('debounce', () => {
    beforeEach(() => {
      vi.useFakeTimers()
    })

    afterEach(() => {
      vi.useRealTimers()
    })

    it('should delay function execution', () => {
      const mockFn = vi.fn()
      const debouncedFn = SearchUtils.debounce(mockFn, 100)

      debouncedFn('test')
      expect(mockFn).not.toHaveBeenCalled()

      vi.advanceTimersByTime(100)
      expect(mockFn).toHaveBeenCalledWith('test')
    })

    it('should cancel previous calls', () => {
      const mockFn = vi.fn()
      const debouncedFn = SearchUtils.debounce(mockFn, 100)

      debouncedFn('first')
      debouncedFn('second')

      vi.advanceTimersByTime(100)

      expect(mockFn).toHaveBeenCalledTimes(1)
      expect(mockFn).toHaveBeenCalledWith('second')
    })
  })
})
----

=== Test d'un composant avec DOM

Test pour la classe `BlogSearch` `src/ts/__tests__/components/BlogSearch.test.ts` :

[source,typescript]
----
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { screen, fireEvent, waitFor } from '@testing-library/dom'
import userEvent from '@testing-library/user-event'
import { BlogSearch } from '@/components/BlogSearch'

// Mock des réponses API
const mockSearchResponse = {
  items: [
    {
      title: 'Premier article',
      url: '/article-1',
      excerpt: 'Description du premier article'
    }
  ],
  total: 1
}

describe('BlogSearch', () => {
  let container: HTMLElement
  let user: ReturnType<typeof userEvent.setup>

  beforeEach(() => {
    user = userEvent.setup()

    // Setup DOM
    document.body.innerHTML = `
      <div>
        <input type="search" id="search" placeholder="Rechercher...">
        <div id="search-results" class="search-results-container"></div>
      </div>
    `

    container = document.body.firstElementChild as HTMLElement

    // Mock fetch
    global.fetch = vi.fn().mockResolvedValue({
      ok: true,
      json: () => Promise.resolve(mockSearchResponse)
    } as Response)
  })

  it('should initialize without errors', () => {
    expect(() => new BlogSearch()).not.toThrow()
  })

  it('should throw error if required elements are missing', () => {
    document.body.innerHTML = '<div></div>'

    expect(() => new BlogSearch()).toThrow('Required elements not found')
  })

  it('should perform search when input has sufficient length', async () => {
    new BlogSearch({ minLength: 2, debounceMs: 0 })

    const searchInput = screen.getByPlaceholderText('Rechercher...')

    await user.type(searchInput, 'typescript')

    await waitFor(() => {
      expect(fetch).toHaveBeenCalledWith('/search.json?q=typescript')
    })
  })

  it('should not search if input is too short', async () => {
    new BlogSearch({ minLength: 3, debounceMs: 0 })

    const searchInput = screen.getByPlaceholderText('Rechercher...')

    await user.type(searchInput, 'ts')

    expect(fetch).not.toHaveBeenCalled()
  })

  it('should display search results', async () => {
    new BlogSearch({ minLength: 2, debounceMs: 0 })

    const searchInput = screen.getByPlaceholderText('Rechercher...')

    await user.type(searchInput, 'typescript')

    await waitFor(() => {
      expect(screen.getByText('Premier article')).toBeInTheDocument()
      expect(screen.getByText('1 résultat(s)')).toBeInTheDocument()
    })
  })

  it('should handle API errors gracefully', async () => {
    global.fetch = vi.fn().mockRejectedValue(new Error('Network error'))

    // Spy sur console.error pour vérifier le logging
    const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {})

    new BlogSearch({ minLength: 2, debounceMs: 0 })

    const searchInput = screen.getByPlaceholderText('Rechercher...')

    await user.type(searchInput, 'typescript')

    await waitFor(() => {
      expect(screen.getByText('Erreur lors de la recherche')).toBeInTheDocument()
      expect(consoleSpy).toHaveBeenCalledWith('Search failed:', expect.any(Error))
    })

    consoleSpy.mockRestore()
  })

  it('should clear results when pressing Escape', async () => {
    new BlogSearch({ minLength: 2, debounceMs: 0 })

    const searchInput = screen.getByPlaceholderText('Rechercher...')

    // Effectuer une recherche d'abord
    await user.type(searchInput, 'typescript')

    await waitFor(() => {
      expect(screen.getByText('Premier article')).toBeInTheDocument()
    })

    // Appuyer sur Escape
    await user.keyboard('{Escape}')

    const resultsContainer = document.getElementById('search-results')!
    expect(resultsContainer.innerHTML).toBe('')
    expect(resultsContainer.classList.contains('visible')).toBe(false)
  })

  it('should escape HTML in results', async () => {
    const maliciousResponse = {
      items: [{
        title: '<script>alert("xss")</script>',
        url: '/safe-url',
        excerpt: 'Safe excerpt'
      }],
      total: 1
    }

    global.fetch = vi.fn().mockResolvedValue({
      ok: true,
      json: () => Promise.resolve(maliciousResponse)
    } as Response)

    new BlogSearch({ minLength: 2, debounceMs: 0 })

    const searchInput = screen.getByPlaceholderText('Rechercher...')

    await user.type(searchInput, 'test')

    await waitFor(() => {
      // Vérifier que le script n'est pas exécuté
      expect(document.body.innerHTML).toContain('&lt;script&gt;')
      expect(document.body.innerHTML).not.toContain('<script>')
    })
  })
})
----

== Configuration des tests E2E avec Playwright

=== Installation de Playwright

[source,bash]
----
npm install -D @playwright/test
npx playwright install
----

=== Configuration Playwright

Créez `playwright.config.js` :

[source,javascript]
----
import { defineConfig, devices } from '@playwright/test'

export default defineConfig({
  testDir: './tests/e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: [
    ['html'],
    ['json', { outputFile: 'test-results/results.json' }]
  ],
  use: {
    baseURL: 'http://localhost:8820',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
  },

  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
    {
      name: 'Mobile Chrome',
      use: { ...devices['Pixel 5'] },
    },
    {
      name: 'Mobile Safari',
      use: { ...devices['iPhone 12'] },
    },
  ],

  webServer: [
    {
      command: 'npm run build && npx jbake -s',
      port: 8820,
      reuseExistingServer: !process.env.CI,
    }
  ],
})
----

=== Tests E2E : Navigation et recherche

Créez `tests/e2e/blog.spec.ts` :

[source,typescript]
----
import { test, expect } from '@playwright/test'

test.describe('Blog Navigation', () => {
  test('should load homepage', async ({ page }) => {
    await page.goto('/')

    await expect(page).toHaveTitle(/Mon Blog/)
    await expect(page.locator('h1')).toBeVisible()
  })

  test('should navigate to blog posts', async ({ page }) => {
    await page.goto('/')

    // Cliquer sur un lien d'article
    await page.click('a[href*="/blog/"]')

    // Vérifier que nous sommes sur une page d'article
    await expect(page.locator('article')).toBeVisible()
    await expect(page.locator('.post-content')).toBeVisible()
  })

  test('should have working RSS feed', async ({ page }) => {
    const response = await page.goto('/feed.xml')

    expect(response?.status()).toBe(200)
    expect(response?.headers()['content-type']).toContain('xml')
  })
})

test.describe('Responsive Design', () => {
  test('should be mobile friendly', async ({ page }) => {
    await page.setViewportSize({ width: 375, height: 667 })
    await page.goto('/')

    // Vérifier que le menu mobile fonctionne
    const menuButton = page.locator('[data-testid="mobile-menu"]')
    if (await menuButton.isVisible()) {
      await menuButton.click()
      await expect(page.locator('.mobile-menu')).toBeVisible()
    }
  })

  test('should adapt layout on tablet', async ({ page }) => {
    await page.setViewportSize({ width: 768, height: 1024 })
    await page.goto('/')

    await expect(page.locator('.container')).toHaveCSS('max-width', '768px')
  })
})
----

Créez `tests/e2e/search.spec.ts` :

[source,typescript]
----
import { test, expect } from '@playwright/test'

test.describe('Search Functionality', () => {
  test.beforeEach(async ({ page }) => {
    // Mocker l'API de recherche
    await page.route('/search.json*', async route => {
      const url = route.request().url()
      const query = new URL(url).searchParams.get('q')

      const mockResponse = {
        items: query ? [
          {
            title: `Résultat pour "${query}"`,
            url: '/blog/test-article',
            excerpt: `Ceci est un extrait contenant ${query}`
          }
        ] : [],
        total: query ? 1 : 0
      }

      await route.fulfill({
        status: 200,
        contentType: 'application/json',
        body: JSON.stringify(mockResponse)
      })
    })

    await page.goto('/')
  })

  test('should show search results', async ({ page }) => {
    const searchInput = page.locator('#search')
    const resultsContainer = page.locator('#search-results')

    await searchInput.fill('typescript')

    // Attendre que les résultats apparaissent
    await expect(resultsContainer).toBeVisible()
    await expect(page.locator('.search-result')).toHaveCount(1)
    await expect(page.getByText('Résultat pour "typescript"')).toBeVisible()
  })

  test('should handle empty search results', async ({ page }) => {
    await page.route('/search.json*', async route => {
      await route.fulfill({
        status: 200,
        contentType: 'application/json',
        body: JSON.stringify({ items: [], total: 0 })
      })
    })

    const searchInput = page.locator('#search')

    await searchInput.fill('nonexistent')

    await expect(page.getByText('Aucun résultat trouvé')).toBeVisible()
  })

  test('should close search results with Escape', async ({ page }) => {
    const searchInput = page.locator('#search')
    const resultsContainer = page.locator('#search-results')

    // Effectuer une recherche
    await searchInput.fill('typescript')
    await expect(resultsContainer).toBeVisible()

    // Appuyer sur Escape
    await page.keyboard.press('Escape')

    await expect(resultsContainer).not.toHaveClass(/visible/)
  })

  test('should handle search API errors', async ({ page }) => {
    await page.route('/search.json*', async route => {
      await route.fulfill({
        status: 500,
        contentType: 'application/json',
        body: JSON.stringify({ error: 'Internal Server Error' })
      })
    })

    // Spy sur les erreurs console
    const consoleErrors: string[] = []
    page.on('console', msg => {
      if (msg.type() === 'error') {
        consoleErrors.push(msg.text())
      }
    })

    const searchInput = page.locator('#search')

    await searchInput.fill('error')

    await expect(page.getByText('Erreur lors de la recherche')).toBeVisible()

    // Vérifier qu'une erreur a été loggée
    await page.waitForTimeout(100)
    expect(consoleErrors.some(error => error.includes('Search failed'))).toBe(true)
  })

  test('should debounce search requests', async ({ page }) => {
    let requestCount = 0

    await page.route('/search.json*', async route => {
      requestCount++
      await route.fulfill({
        status: 200,
        contentType: 'application/json',
        body: JSON.stringify({ items: [], total: 0 })
      })
    })

    const searchInput = page.locator('#search')

    // Taper rapidement plusieurs caractères
    await searchInput.pressSequentially('typescript', { delay: 50 })

    // Attendre que le debounce se termine
    await page.waitForTimeout(500)

    // Vérifier qu'une seule requête a été envoyée
    expect(requestCount).toBe(1)
  })
})

test.describe('Search Accessibility', () => {
  test('should be keyboard navigable', async ({ page }) => {
    await page.goto('/')

    // Naviguer au champ de recherche avec Tab
    await page.keyboard.press('Tab')
    await expect(page.locator('#search')).toBeFocused()

    // Effectuer une recherche
    await page.keyboard.type('typescript')

    // Vérifier que les résultats sont accessibles au clavier
    await page.keyboard.press('Tab')
    await expect(page.locator('.search-result a').first()).toBeFocused()
  })

  test('should have proper ARIA attributes', async ({ page }) => {
    await page.goto('/')

    const searchInput = page.locator('#search')
    const resultsContainer = page.locator('#search-results')

    // Vérifier les attributs ARIA
    await expect(searchInput).toHaveAttribute('role', 'searchbox')
    await expect(resultsContainer).toHaveAttribute('role', 'region')
    await expect(resultsContainer).toHaveAttribute('aria-live', 'polite')
  })
})
----

== Scripts de test intégrés

Mettez à jour votre `package.json` :

[source,json]
----
{
  "scripts": {
    "dev:ts": "vite",
    "build:ts": "vite build",
    "dev": "concurrently \"npm run dev:ts\" \"./gradlew jbakeServe\"",
    "build": "npm run build:ts && ./gradlew jbake",

    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage",
    "test:watch": "vitest --watch",

    "test:e2e": "playwright test",
    "test:e2e:ui": "playwright test --ui",
    "test:e2e:headed": "playwright test --headed",
    "test:e2e:debug": "playwright test --debug",

    "test:all": "npm run test:coverage && npm run test:e2e",
    "test:ci": "npm run build && npm run test:coverage && npm run test:e2e"
  }
}
----

== Intégration avec le build Gradle

Mettez à jour votre `build.gradle` :

[source,groovy]
----
plugins {
    id 'org.jbake.site' version '5.3.0'
    id 'com.github.node-gradle.node' version '3.5.1'
}

// Tasks de test
task testUnit(type: NpmTask) {
    args = ['run', 'test:coverage']
    inputs.dir('src/ts')
    outputs.dir('coverage')
}

task testE2E(type: NpmTask) {
    args = ['run', 'test:e2e']
    inputs.dir('tests/e2e')
    inputs.dir('build') // Dépend du site généré
    outputs.dir('test-results')
    dependsOn jbake
}

task testAll(type: NpmTask) {
    args = ['run', 'test:all']
    dependsOn buildTypeScript
}

// Configuration des dépendances
buildTypeScript.dependsOn npmInstall
testUnit.dependsOn buildTypeScript
jbake.dependsOn testUnit  // Les tests doivent passer avant le build

// Task pour le pipeline CI/CD
task ciPipeline {
    dependsOn testAll
    description = 'Pipeline complet : build, tests unitaires et E2E'
}
----

== Intégration CI/CD

=== GitHub Actions

Créez `.github/workflows/test.yml` :

[source,yaml]
----
name: Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [18, 20]

    steps:
    - uses: actions/checkout@v4

    - name: Setup Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'

    - name: Setup Java
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'

    - name: Install dependencies
      run: npm ci

    - name: Run unit tests
      run: npm run test:coverage

    - name: Build site
      run: ./gradlew jbake

    - name: Install Playwright browsers
      run: npx playwright install --with-deps

    - name: Run E2E tests
      run: npm run test:e2e

    - name: Upload coverage reports
      uses: codecov/codecov-action@v4
      with:
        file: ./coverage/lcov.info

    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: playwright-report-${{ matrix.node-version }}
        path: playwright-report/
        retention-days: 30
----

== Bonnes pratiques de test

=== Tests unitaires

* **Testez la logique métier** - Pas les détails d'implémentation
* **Un test = un comportement** - Tests focalisés et lisibles
* **Arrange, Act, Assert** - Structure claire des tests
* **Mockez les dépendances externes** - Tests isolés et rapides

=== Tests d'intégration

* **Testez les interactions** - Entre composants et avec le DOM
* **Simulez les conditions réelles** - Événements utilisateur authentiques
* **Vérifiez les effets de bord** - État global, stockage local, etc.

=== Tests E2E

* **Testez les parcours critiques** - Workflows métier importants
* **Tests stables** - Utilisez des sélecteurs robustes
* **Données de test isolées** - Évitez les dépendances entre tests
* **Performance** - Limitez le nombre de tests E2E

=== Organisation des tests

Pour maintenir une suite de tests claire et gérable, suivez ces principes :

* **Colocation** : Placez les tests unitaires (`.test.ts` ou `.spec.ts`) à côté du code qu'ils testent, idéalement dans un sous-répertoire `__tests__`.
Cela facilite la navigation et garantit que les tests sont supprimés ou déplacés avec le code correspondant.

[source,typescript]
----
    src/
    └── ts/
        ├── components/
        │   ├── MyComponent.ts
        │   └── __tests__/
        │       └── MyComponent.test.ts // Test unitaire du composant
        └── utils/
            ├── DateUtils.ts
            └── __tests__/
                └── DateUtils.test.ts // Test unitaire de l'utilitaire
----

* **Dossiers dédiés pour E2E et intégration** : Créez des dossiers de haut niveau pour les tests E2E (`tests/e2e`) et les tests d'intégration (si distincts de l'unité, par exemple `tests/integration`).
Cela sépare clairement les types de tests et leurs configurations.

[source,typescript]
----
    tests/
    ├── e2e/                     // Playwright tests
    │   ├── navigation.spec.ts
    │   └── user-flow.spec.ts
    └── integration/             // Vitest (jsdom) pour des scénarios plus complexes
        ├── form-submission.test.ts
        └── data-fetching.test.ts
----

* **Nommage cohérent** : Utilisez des conventions de nommage claires comme `*.test.ts` pour Vitest et `*.spec.ts` pour Playwright (bien que les deux puissent utiliser l'un ou l'autre).
Assurez-vous que le nom du fichier de test reflète clairement ce qu'il teste.

* **Fichiers de fixtures/mocks** : Centralisez les données de test, les mocks et les helpers réutilisables dans des dossiers `fixtures` ou `mocks` dédiés au sein de vos répertoires de tests.

[source,typescript]
----
tests/
└── e2e/
    └── fixtures/
    ├── test-data.json
    └── auth-helper.ts
----

== Conclusion

L'intégration de tests unitaires avec **Vitest** et de tests E2E avec **Playwright** transforme le développement de votre site JBake en une expérience beaucoup plus robuste et fiable.
En adoptant ces pratiques et en les automatisant via **Gradle** et **GitHub Actions**, vous assurez que chaque modification de code est vérifiée et que votre site statique reste fonctionnel et performant.

Les tests ne sont pas un frein, mais un investissement qui vous fera gagner du temps et de la tranquillité d'esprit à long terme.